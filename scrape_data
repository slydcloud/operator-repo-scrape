```--- FILE: .github/workflows/aws.yml ---
name: Platform AWS ECS Deployment

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Log into Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: platform
        IMAGE_TAG: $GITHUB_SHA
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Update ECS service
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ecs/platform-task.json
        service: platform-service
        cluster: platform-cluster
        wait-for-service-stability: true
EOF```
```--- FILE: Application/Application.csproj ---
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <RootNamespace>SLYD.Application</RootNamespace>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="AutoMapper" Version="13.0.1" />
      <PackageReference Include="Microsoft.AspNetCore.Components.Authorization" Version="8.0.0" />
      <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
      <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="9.0.0-preview.5.24306.7" />
      <PackageReference Include="Serilog.AspNetCore" Version="8.0.3" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\Domain\Domain.csproj" />
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Interfaces\Features\Lxd\LxdServer\" />
    </ItemGroup>

</Project>
EOF```
```--- FILE: Application/DependencyInjection.cs ---
using Microsoft.Extensions.DependencyInjection;
using SLYD.Application.Features;
using SLYD.Application.Features.Cloudflare;
using SLYD.Application.Features.CustomerFeature;
using SLYD.Application.Features.Lxd;
using SLYD.Application.Features.Lxd.LxdImages;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Interfaces.Features.UserService;
using SLYD.Application.Pipelines;
using SLYD.Application.Handlers;
using SLYD.Application.Interfaces.Features.Cloudflare;
using SLYD.Application.Interfaces.Features.CustomerFeature;
using SLYD.Application.Interfaces.Features.Lxd;
using SLYD.Application.Interfaces.Features.Lxd.LxdImages;

namespace SLYD.Application;

public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        //Add Features
        // services.AddScoped<ILxdInstanceService, LxdInstanceService>();
        services.AddScoped<IAddLxdServer, AddLxdServer>();
        services.AddScoped<ILxdImageFeatures, LxdImageFeatures>();
        services.AddScoped<ILxdInstanceFeatures, LxdInstanceFeatures>();
        services.AddScoped<ICloudflareFeatures, CloudflareFeatures>();
        services.AddScoped<IProviderServerFeatures, ProviderServerFeatures>();
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<ICustomerRentalService, CustomerRentalService>();
        services.AddScoped<IInstallScriptFeatures, InstallScriptFeatures>();
        
        //Add Message Handlers
        services.AddScoped<LxdServerMessageHandler>();
        services.AddScoped<LxdInstanceMessageHandler>();

        //Add Pipelines
        services.AddScoped<DeleteLxdServerPipeline>();
        services.AddScoped<CreateLxdInstance>();
        services.AddScoped<DeleteLxdInstance>();
        
        return services;
    }
}
EOF```
```--- FILE: Domain/Domain.csproj ---
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <RootNamespace>Domain</RootNamespace>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Microsoft.Extensions.Options" Version="8.0.1" />
    </ItemGroup>
</Project>
EOF```
```--- FILE: Infrastructure/Infrastructure.csproj ---
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <RootNamespace>SLYD.Infrastructure</RootNamespace>
    </PropertyGroup>
    
    <ItemGroup>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="8.0.6" />
        <PackageReference Include="RabbitMQ.Client" Version="6.4.0" />
        <PackageReference Include="Auth0.AspNetCore.Authentication" Version="1.4.1" />
        <PackageReference Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" Version="8.0.6" />
        <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.6" />
        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.6">
        <PrivateAssets>all</PrivateAssets>
        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      </PackageReference>
      <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
      <PackageReference Include="Microsoft.Extensions.Options" Version="8.0.1" />
      <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.0" />
      <PackageReference Include="Serilog.AspNetCore" Version="8.0.3" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\Application\Application.csproj" />
    </ItemGroup>
</Project>
EOF```
```--- FILE: Infrastructure/DependencyInjection.cs ---
using System.Security.Claims;
using Auth0.AspNetCore.Authentication;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.AspNetCore.Authentication.OpenIdConnect;
using Microsoft.EntityFrameworkCore;
using SLYD.Application.Features;
using SLYD.Application.Features.CustomerFeature;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Interfaces.Features.CustomerFeature;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Application.Interfaces.Features.UserService;
using SLYD.Application.Interfaces.Infrastructure;
using SLYD.Application.Interfaces.Infrastructure.Internal;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Application.Interfaces.Infrastructure.Repositories;
using SLYD.Application.Interfaces.Pipelines;
using SLYD.Application.Interfaces.RabbitMQ;
using SLYD.Application.Interfaces.WebConsole;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;
using SLYD.Infrastructure.Services;
using SLYD.Infrastructure.Services.Auth;
using SLYD.Infrastructure.Data;
using SLYD.Infrastructure.Repositories;
using SLYD.Infrastructure.Services.Cloudflare;
using SLYD.Infrastructure.Services.WebConsole.Rent;
using SLYD.Infrastructure.Services.Helper;
using SLYD.Infrastructure.Services.Internal;
using SLYD.Infrastructure.Services.Lxd;
using SLYD.Infrastructure.Services.RabbitMQ;
using SLYD.Infrastructure.Services.RabbitSender;
using TokenProvider = SLYD.Infrastructure.Services.Auth.TokenProvider;

namespace SLYD.Infrastructure;


public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddSingleton(configuration);
        services.AddDatabase(configuration);

        services.AddRabbitMQ();
        services.AddLxd();
        services.AddCloudflare();
        services.AddHttpClient();
        services.AddWebConsole();
        
        services.AddScoped<ILxdInstanceOperationService, LxdInstanceOperationService>();
        services.AddScoped<IImageLibraryService, ImageLibraryService>();
        services.AddAuth0Services(configuration);

        services.AddLogging();

        return services;
    }

    public static IServiceCollection AddRabbitMQ(this IServiceCollection services)
    {
        services.AddScoped<RabbitFactoryService>();
        services.AddScoped<IRabbitSenderService, RabbitSenderService>();
        
        return services;
    }
    
    public static IServiceCollection AddHttpClient(this IServiceCollection services)
    {
        services.AddScoped<HttpClientHandlerService>();
        services.AddTransient<HttpClient>();
        
        return services;
    }
    
    public static IServiceCollection AddWebConsole(this IServiceCollection services)
    {
        services.AddScoped<ProviderService>();
        services.AddScoped<PublicKeyService>();
        services.AddScoped<RandomStringGenerator>();
        services.AddScoped<IProviderServerMetricsService, ProviderServerMetricsService>();
        services.AddScoped<IUserPublicKeyService, UserPublicKeyService>();
        
        
        return services;
    }
    
    public static IServiceCollection AddLxd(this IServiceCollection services)
    {
        services.AddScoped<WebSocketService>();
        services.AddScoped<RentInstanceService>();
        
        return services;
    }
    
    public static IServiceCollection AddCloudflare(this IServiceCollection services)
    {
        services.AddScoped<ICloudflareDNS, CloudflareDNSService>();
        services.AddScoped<ICloudflareTunnel, CloudflareTunnelService>();
        
        return services;
    }
    
    public static IServiceCollection AddAuth0Services(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddScoped<IAuth0Service, Auth0Service>();
        services.AddSingleton<ITokenProvider, TokenProvider>();
        
        services.AddAuth0WebAppAuthentication(options =>
        {
            options.Domain = configuration["Auth0:Domain"];
            options.ClientId = configuration["Auth0:ClientId"];
            options.Scope = "openid profile email";

            options.OpenIdConnectEvents = new OpenIdConnectEvents
            {
                OnTicketReceived = async context =>
                {
                    // Get user's claims
                    var claims = context.Principal.Claims;
                    // Extract user's information from claims
                    var userId = claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
                    var email = claims.FirstOrDefault(c => c.Type == ClaimTypes.Email)?.Value;

                    // Get a reference to your User Service
                    var userContext = context.HttpContext.RequestServices.GetRequiredService<IUserService>();
                    
                    // // get user
                    var user = await userContext.GetUserAsync(userId);
                    
                    // Check if user exists in your database, if not, create a new user
                    if (user == null)
                    { ;
                        user = new User() {Email = email, AuthId = userId };
                        await userContext.AddUser(user);
                    
                        var storedUser = await userContext.GetUserAsync(userId);
                    
                        //Create Customer From User
                        var customer = new Customer() {UserId = storedUser.Id };
                        await userContext.AddCustomer(customer);
                        
                        //Create Provider From User
                        var provider = new Provider() {UserId = storedUser.Id };
                        await userContext.AddProvider(provider);
                    }
                }
            };
        });
        
        services.AddScoped<Auth0Service>();

        return services;
    }

    public static IServiceCollection AddDatabase(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddScoped<IInstanceRepository, InstanceRepository>();
        services.AddScoped<IProviderServerRepository, ProviderServerRepository>();
        services.AddScoped<IUserRepostiory, UserRepository>();
        services.AddScoped<IImageLibraryRepository, ImageLibraryRepository>();
        services.AddScoped<IRentalRepository, RentalRepository>();
        services.AddScoped<IUserPublicKeyRepository, UserPublicKeyRepository>();
        services.AddScoped<IScriptRepository, ScriptRepository>();
        services.AddScoped<IScriptSeedService, ScriptSeedService>();

        services.AddDbContext<SlydDbContext>(
            options => options.UseNpgsql(configuration.GetConnectionString("Conn"))
                .AddInterceptors(new SoftDeleteInterceptor()));
        return services;
    }
}
EOF```
```--- FILE: LxdBackground/LxdBackground.csproj ---
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\Application\Application.csproj" />
      <ProjectReference Include="..\Domain\Domain.csproj" />
      <ProjectReference Include="..\Infrastructure\Infrastructure.csproj" />
    </ItemGroup>

</Project>
EOF```
```--- FILE: LxdBackground/Program.cs ---
using LxdBackground.Services;
using Serilog;
using Microsoft.EntityFrameworkCore;
using RabbitRecieverFactory.Services;
using SLYD.Infrastructure.Data;
using SLYD.Application;
using SLYD.Infrastructure;

string environment = Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT") ?? "Development";
Console.WriteLine($"DOTNET_ENVIRONMENT: {Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT")}"); // Log the environment variable

Environment.SetEnvironmentVariable("DOTNET_ENVIRONMENT", environment);

HostApplicationBuilderSettings settings = new()
{
    Args = args,
    Configuration = new ConfigurationManager(),
    ContentRootPath = Directory.GetCurrentDirectory(),
};

settings.Configuration.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true);

settings.Configuration.AddEnvironmentVariables(prefix: "PREFIX_");
settings.Configuration.AddCommandLine(args);

var builder = Host.CreateApplicationBuilder(settings);

//Add support to logging with SERILOG
builder.Services.AddSerilog((services, loggerConfiguration) => loggerConfiguration
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day));

builder.Services.AddHostedService<WorkerService>();
builder.Services.AddScoped<LxdFactoryService>();
builder.Services.AddSingleton<IConfiguration>(builder.Configuration);
builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);
builder.Services.AddTransient<HttpClient>();


builder.Services.AddDbContext<SlydDbContext>(
    options => options.UseNpgsql(builder.Configuration.GetConnectionString("Conn")),
    ServiceLifetime.Scoped);

var host = builder.Build();
host.Run();
EOF```
```--- FILE: LxdBackground/Properties/launchSettings.json ---
﻿{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:56656",
      "sslPort": 44350
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5092",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7006;http://localhost:5092",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
EOF```
```--- FILE: LxdBackground/Services/LxdFactoryService.cs ---
using System.Diagnostics;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models.ProviderModels;

namespace LxdBackground.Services;

public class LxdFactoryService
{    
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<LxdFactoryService> _logger;
    private List<ProviderServer> providerServers;
    private IProviderServerRepository _providerServerRepository;
    private HttpClient _httpClient;

    private const int MaxRetryAttempts = 5;
    private const int InitialDelayMilliseconds = 1000;

    public LxdFactoryService(ILogger<LxdFactoryService> logger, IConfiguration configuration, IProviderServerRepository providerServerRepository, HttpClient httpClient, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _providerServerRepository = providerServerRepository;
        _httpClient = httpClient;
        _serviceProvider = serviceProvider;
    }

    public async Task GetLxdStats()
    {
        const int delayMinutes = 5;
        const int delayMilliseconds = delayMinutes * 60 * 1000;

        while (true)
        {
            var stopwatch = Stopwatch.StartNew();

            providerServers = await _providerServerRepository.GetProvisionedServersAsync();

            foreach (var server in providerServers)
            {
                int retryAttempts = 0;
                int delay = InitialDelayMilliseconds;

                while (retryAttempts < MaxRetryAttempts)
                {
                    try
                    {
                        using (var scope = _serviceProvider.CreateScope())
                        {
                            var providerServerRepository =
                                scope.ServiceProvider.GetRequiredService<IProviderServerRepository>();

                            // Logic for LXD here
                            string lxdUri =
                                await providerServerRepository.GetProviderServerLxdUriFromServerId(server.Id);
                            var uri = "https://" + lxdUri + "/1.0/instances?project=default";

                            HttpResponseMessage response = await _httpClient.GetAsync(uri);

                            if (response.IsSuccessStatusCode)
                                await providerServerRepository.AddProviderServerMetrics(server.Id, true);
                            else
                                await providerServerRepository.AddProviderServerMetrics(server.Id, false);

                            _logger.LogInformation("Connected to LXD Server");
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        retryAttempts++;
                        _logger.LogError($"Connection attempt {retryAttempts} failed: {ex.Message}");

                        if (retryAttempts >= MaxRetryAttempts)
                        {
                            _logger.LogError("Max retry attempts reached. Moving to next server.");
                        }

                        await Task.Delay(delay);
                        delay *= 2; // Exponential backoff
                    }
                }
            }

            stopwatch.Stop();
            int elapsedMilliseconds = (int)stopwatch.ElapsedMilliseconds;

            if (elapsedMilliseconds < delayMilliseconds)
            {
                int remainingDelay = delayMilliseconds - elapsedMilliseconds;
                await Task.Delay(remainingDelay);
            }
        }
    }
}
EOF```
```--- FILE: LxdBackground/appsettings.Development.json ---
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
EOF```
```--- FILE: LxdBackground/appsettings.json ---
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
EOF```
```--- FILE: RabbitConsumer/Dockerfile ---
﻿FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 6000

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["RabbitConsumer/RabbitConsumer.csproj", "RabbitConsumer/"]
COPY ["Application/Application.csproj", "Application/"]
COPY ["Domain/Domain.csproj", "Domain/"]
COPY ["Infrastructure/Infrastructure.csproj", "Infrastructure/"]
RUN dotnet restore "RabbitConsumer/RabbitConsumer.csproj"
COPY . .
WORKDIR "/src/RabbitConsumer"
RUN dotnet build "RabbitConsumer.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "RabbitConsumer.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENV ASPNETCORE_ENVIRONMENT=Development
ENTRYPOINT ["dotnet", "RabbitConsumer.dll"]
EOF```
```--- FILE: RabbitConsumer/Program.cs ---
using Serilog;
using Microsoft.EntityFrameworkCore;
using RabbitRecieverFactory.Services;
using SLYD.Infrastructure.Data;
using SLYD.Application;
using SLYD.Application.Services;
using SLYD.Infrastructure;

string environment = Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT") ?? "Development";
Console.WriteLine($"DOTNET_ENVIRONMENT: {Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT")}"); // Log the environment variable

Environment.SetEnvironmentVariable("DOTNET_ENVIRONMENT", environment);

HostApplicationBuilderSettings settings = new()
{
    Args = args,
    Configuration = new ConfigurationManager(),
    ContentRootPath = Directory.GetCurrentDirectory(),
};

settings.Configuration.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true);

settings.Configuration.AddEnvironmentVariables(prefix: "PREFIX_");
settings.Configuration.AddCommandLine(args);

var builder = Host.CreateApplicationBuilder(settings);

//Add support to logging with SERILOG
builder.Services.AddSerilog((services, loggerConfiguration) => loggerConfiguration
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day));

builder.Services.AddHostedService<WorkerService>();
builder.Services.AddSingleton<IConfiguration>(builder.Configuration);
builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);
builder.Services.AddSingleton<RabbitFactoryService>();
builder.Services.AddTransient<HttpClient>();
builder.Services.AddScoped<MessageDispatcher>();


builder.Services.AddDbContext<SlydDbContext>(
    options => options.UseNpgsql(builder.Configuration.GetConnectionString("Conn")),
    ServiceLifetime.Scoped);

var host = builder.Build();
host.Run();
EOF```
```--- FILE: RabbitConsumer/RabbitConsumer.csproj ---
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <RootNamespace>RabbitReciever</RootNamespace>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="RabbitMQ.Client" Version="6.4.0" />
        <PackageReference Include="Serilog.AspNetCore" Version="8.0.3" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\Application\Application.csproj" />
      <ProjectReference Include="..\Domain\Domain.csproj" />
      <ProjectReference Include="..\Infrastructure\Infrastructure.csproj" />
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Logs\" />
    </ItemGroup>
</Project>
EOF```
```--- FILE: RabbitConsumer/appsettings.Development.json ---
{
  "Serilog": {
    "Using":  [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": "Information",
    "WriteTo": [
      { "Name": "Console" },
      { "Name": "File", "Args": { "path": "Logs/log.txt" } }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "Conn": "Host=blazor-dev.cluster-cjw8gk2y8j5y.us-east-1.rds.amazonaws.com;Port=5432;Database=Slyd;Username=postgres;Password=xP:)7lZB:O?|<(Bdo07%~tmZH7zr;"
  },
  "CloudflareUsers" : {
    "BearerToken" : "_2zX4Pii_DEEc1M1wGZ1mNimq9T05XaiNzMTdWaI",
    "AccountId" : "08dc69dd4aaaf3f1434d349404185e03",
    "ZoneId" : "2bb11df44b99f8214968f786ea3733b1",
    "BaseUri" : "https://api.cloudflare.com/",
    "Secret" : "c2VjcmV0IHN0cmluZyBnb2VzIGhlcmU="
  },
  "CloudflareManagement" : {
    "BearerToken" : "_2zX4Pii_DEEc1M1wGZ1mNimq9T05XaiNzMTdWaI",
    "AccountId" : "08dc69dd4aaaf3f1434d349404185e03",
    "ZoneId" : "d770d60d872c8fca4a2270963a42c5e5",
    "BaseUri" : "https://api.cloudflare.com/",
    "Secret" : "c2VjcmV0IHN0cmluZyBnb2VzIGhlcmU="
  },
  "RabbitMQ" : {
    "RabbitMqUri": "amqp://sysadmin:f5aeVFS1GmRH44@ec2-35-93-47-1.us-west-2.compute.amazonaws.com:5672",
    "ExchangeName": "SlydExchange",
    "QueueName": "SlydQueue",
    "RoutingKey": "SlydRoutingKey"
  }
}
EOF```
```--- FILE: RabbitConsumer/appsettings.Production.json ---
{
  "Serilog": {
    "Using":  [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": "Information",
    "WriteTo": [
      { "Name": "Console" },
      { "Name": "File", "Args": { "path": "Logs/log.txt" } }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "Conn": "Host=blazor-dev.cluster-cjw8gk2y8j5y.us-east-1.rds.amazonaws.com;Port=5432;Database=Slyd;Username=postgres;Password=xP:)7lZB:O?|<(Bdo07%~tmZH7zr;"
  },
  "CloudflareUsers" : {
    "BearerToken" : "_2zX4Pii_DEEc1M1wGZ1mNimq9T05XaiNzMTdWaI",
    "AccountId" : "08dc69dd4aaaf3f1434d349404185e03",
    "ZoneId" : "2bb11df44b99f8214968f786ea3733b1",
    "BaseUri" : "https://api.cloudflare.com/",
    "Secret" : "c2VjcmV0IHN0cmluZyBnb2VzIGhlcmU="
  },
  "CloudflareManagement" : {
    "BearerToken" : "_2zX4Pii_DEEc1M1wGZ1mNimq9T05XaiNzMTdWaI",
    "AccountId" : "08dc69dd4aaaf3f1434d349404185e03",
    "ZoneId" : "d770d60d872c8fca4a2270963a42c5e5",
    "BaseUri" : "https://api.cloudflare.com/",
    "Secret" : "c2VjcmV0IHN0cmluZyBnb2VzIGhlcmU="
  },
  "RabbitMQ" : {
    "RabbitMqUri": "amqp://sysadmin:f5aeVFS1GmRH44@ec2-35-93-47-1.us-west-2.compute.amazonaws.com:5672",
    "ExchangeName": "SlydExchange",
    "QueueName": "SlydQueue",
    "RoutingKey": "SlydRoutingKey"
  }
}
EOF```
```--- FILE: RabbitConsumer/appsettings.json ---
{
  "Serilog": {
    "Using":  [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": "Information",
    "WriteTo": [
      { "Name": "Console" },
      { "Name": "File", "Args": { "path": "Logs/log.txt" } }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "AllowedHosts": "*"
}
EOF```


--- FILE: Application/Features/Cloudflare/CloudflareFeatures.cs ---
using System.Net;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features.Cloudflare;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Entities.Cloudflare;
using SLYD.Domain.Enums;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Features.Cloudflare;

public class CloudflareFeatures : ICloudflareFeatures
{
    ILogger<CloudflareFeatures> _logger;
    private ICloudflareDNS _cloudflareDns;
    private ICloudflareTunnel _cloudflareTunnel;
    private CloudflareType cloudflareType;
    private IProviderServerRepository _providerServerRepository;
    private IInstanceRepository _instanceRepository;
    
    public CloudflareFeatures(ILogger<CloudflareFeatures> logger, ICloudflareDNS cloudflareDns,
        ICloudflareTunnel cloudflareTunnel, IProviderServerRepository providerServerRepository,
        IInstanceRepository instanceRepository)
    {
        _cloudflareDns = cloudflareDns;
        _cloudflareTunnel = cloudflareTunnel;
        _providerServerRepository = providerServerRepository;
        _instanceRepository = instanceRepository;
        _logger = logger;
        
        //Configures Cloudflare to use the slydtunnels.com domain and credentials
        _cloudflareTunnel.SetCloudflareType(CloudflareType.User);
    }

    public async Task SetCloudflareType(CloudflareType type)
    {
        cloudflareType = type;
        await _cloudflareDns.SetCloudflareType(type);
        await _cloudflareTunnel.SetCloudflareType(type);
    }
    
    public async Task<string> TestCloudflareConnectivity(string cfd_tunnel_id)
    {
        return await _cloudflareTunnel.TestTunnel(cfd_tunnel_id);
    }

    public async Task<string> InitiateInstanceTunnelCreation(Guid instanceId)
    {
        _logger.LogInformation("Tunnel Creation Initiated");
        
        string cfd_tunnel_id = "";
    
        try
        {
            HttpResponseMessage tunnelResponseMessage = await _cloudflareTunnel.CreateCloudflareTunnel(instanceId);
            _logger.LogInformation("Tunnel Response: " + await tunnelResponseMessage.Content.ReadAsStringAsync());
    
            if (tunnelResponseMessage.StatusCode == HttpStatusCode.OK)
            {
                CreateTunnelResponse tunnelResponse =
                    JsonSerializer.Deserialize<CreateTunnelResponse>
                        (await tunnelResponseMessage.Content.ReadAsStringAsync());
                
                cfd_tunnel_id = tunnelResponse.result.id;
            }
            else
            {
                _logger.LogError("Response Does Not Indicate Success : " +
                                 await tunnelResponseMessage.Content.ReadAsStringAsync());
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.Message);
        }
        
        return cfd_tunnel_id;
    }

    public async Task<string> InitiateDnsCreation(string cfd_tunnel_id, Guid instanceId)
    {
        string dns_id = "";
        
        
        try{
            if (cfd_tunnel_id.Length > 0)
            {
                await _cloudflareDns.SetCloudflareType(CloudflareType.User);
                HttpResponseMessage response = await _cloudflareDns.CreateDNSRecord(cfd_tunnel_id, instanceId.ToString());
                _logger.LogInformation("DNS Response: " + await response.Content.ReadAsStringAsync());
                
                if(response.StatusCode == HttpStatusCode.OK)
                {
                    DnsApiResponse dnsResponse = JsonSerializer.Deserialize<DnsApiResponse>
                        (await response.Content.ReadAsStringAsync());
                    dns_id = dnsResponse.result.id;
                }
                else
                {
                    _logger.LogError("Response Does Not Indicate Success : " + await response.Content.ReadAsStringAsync());
                }
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
        return dns_id;
    }
    
    public async Task<bool> InitiateInstanceTunnelConfiguration(string cfd_tunnel_id)
    {
        HttpResponseMessage message = await _cloudflareTunnel.ConfigureCloudflareTunnel(cfd_tunnel_id, cloudflareType);
        
        if(message.StatusCode == HttpStatusCode.OK)
        {
            _logger.LogInformation("Tunnel Configured Successfully");
            return true;
        }
        else
        {
            _logger.LogError("Response Does Not Indicate Success : " + await message.Content.ReadAsStringAsync());
            return false;
        }
    }
    
    public async Task<string> GetTunnelSecret(string cfd_tunnel_id)
    {
        HttpResponseMessage responseMessage = await _cloudflareTunnel.GetInstallScript(cfd_tunnel_id);
        
        if(responseMessage.StatusCode == HttpStatusCode.OK)
        {
            GetSecretApiResponse apiResponse = 
                JsonSerializer.Deserialize<GetSecretApiResponse>(await responseMessage.Content.ReadAsStringAsync());
            
            _logger.LogInformation("Get Install Script:  " + apiResponse.result);

            return apiResponse.result;
        }
        else
        {
            _logger.LogError("Response Does Not Indicate Success : " + await responseMessage.Content.ReadAsStringAsync());
            return "Failed";
        }
    }

    public async Task<string> ReconfigureCloudflareTunnel(string cfd_tunnel_id, List<string> endpointList, string dns_record, string subdomain)
    {
       return await _cloudflareTunnel.ReconfigureCloudflareTunnel(cfd_tunnel_id, endpointList, dns_record, subdomain);
    }

    public async Task<HttpResponseMessage> CreateEndpointDnsRecord(string cfd_tunnel_id, string dns_record)
    {
        return await _cloudflareDns.CreateDNSRecord(cfd_tunnel_id, dns_record);
    }
    
    public async Task<HttpResponseMessage> DeleteDnsRecord(Guid id, CloudflareType type)
    {
        string dnsId = "";
        try
        {


            if (type == CloudflareType.Management)
            {
                var providerServer = await _providerServerRepository.GetProviderServerIgnoreIsDeleted(id);
                dnsId = providerServer.CloudflareDnsId;
            }
            else
            {
                //REFACTOR
                // var instance = await _instanceRepository.GetInstanceIgnoreIsDeleted(id);
                // dnsId = instance.CloudflareDnsId;
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }

        return await _cloudflareDns.DeleteDNSRecord(dnsId);
    }
    
    public async Task<HttpResponseMessage> DeleteTunnel(Guid providerServerId)
    {
        return await _cloudflareTunnel.DeleteCloudflareTunnel(providerServerId);
    }
}EOF
--- FILE: Application/Features/Customer/CustomerRentalService.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features.CustomerFeature;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models;

namespace SLYD.Application.Features.CustomerFeature;

public class CustomerRentalService : ICustomerRentalService
{
    IRentalRepository _rentalRepository;
    ILogger<CustomerRentalService> _logger;
    
    public CustomerRentalService(IRentalRepository rentalRepository, ILogger<CustomerRentalService> logger)
    {
        _rentalRepository = rentalRepository;
        _logger = logger;
    }
    public async Task<List<InstanceRental>> GetRentalsAsync(Guid customerId)
    {
        return await _rentalRepository.GetRentalsAsync(customerId);
    }
}EOF
--- FILE: Application/Features/Customer/ImageLibraryService.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features.CustomerFeature;
using SLYD.Application.Interfaces.WebConsole;
using SLYD.Domain.Models;

namespace SLYD.Application.Features.CustomerFeature;

public class ImageLibraryService : IImageLibraryService
{
    private IImageLibraryRepository _imageLibraryRepository;
    private ILogger<ImageLibraryService> _logger;
    
    public ImageLibraryService(IImageLibraryRepository imageLibraryRepository, ILogger<ImageLibraryService> logger)
    {
        _imageLibraryRepository = imageLibraryRepository;
        _logger = logger;
    }
    
    public async Task<List<ImageLibrary>> GetImageLibrary()
    {
        _logger.LogInformation("ImageLibraryService GetImageLibrary");
        return await _imageLibraryRepository.GetImageLibrary();
    }
    
    public async Task<List<ImageLibraryEndpoint>> GetImageLibraryEndpoints(Guid imageLibraryId)
    {
        _logger.LogInformation("ImageLibraryService GetImageLibraryEndpoints");
        return await _imageLibraryRepository.GetImageLibraryEndpoints(imageLibraryId);
    }
}EOF
--- FILE: Application/Features/Customer/LxdInstanceService.cs ---
using SLYD.Domain.Enums;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features.CustomerLxd;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Entities.Lxd.Images;
using SLYD.Domain.Models;

namespace SLYD.Application.Features.CustomerFeature;

public class LxdInstanceService : ILxdInstanceService
{
    private readonly ILogger<LxdInstanceService> _logger;
    private readonly IInstanceRepository _instanceRepository;
    private readonly ICloudflareTunnel _cloudflareTunnel;
    private readonly ICloudflareDNS _cloudflareDNS;
    private readonly ILxdInstanceOperationService _lxdInstanceOperationService;
    private readonly IProviderServerRepository _providerServerRepository;
    
    public LxdInstanceService(ILogger<LxdInstanceService> logger, IInstanceRepository instanceRepository,
        ICloudflareTunnel cloudflareTunnel, ICloudflareDNS cloudflareDNS, ILxdInstanceService lxdInstanceService,
        IProviderServerRepository providerServerRepository, ILxdInstanceOperationService instanceOperationService)
    {
        _instanceRepository = instanceRepository;
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareDNS = cloudflareDNS;
        _lxdInstanceOperationService = instanceOperationService;
        _providerServerRepository = providerServerRepository;
        _logger = logger;
    }
    
    public async Task<Instance> CreateLxdInstanceAsync(Instance instance)
    {
        await _instanceRepository.AddInstance(instance);
        return instance;
    }
    public async Task<List<Instance>> GetLxdInstancesAsync(Guid customerId)
    {
        return await _instanceRepository.GetInstances(customerId);
    }
    public async Task<List<Instance>> GetLxdInstancesIgnoreFiltersAsync(Guid customerId)
    {
        return await _instanceRepository.GetInstances(customerId);
    }
    
    public async Task DeleteLxdInstanceAsync(Guid instanceId)
    {
        Instance instance = await _instanceRepository.GetInstance(instanceId);
        
        _logger.LogInformation(instance.Id.ToString());
        
        if (instance != null)
        {
            await _cloudflareDNS.SetCloudflareType(CloudflareType.User);
            await _cloudflareTunnel.SetCloudflareType(CloudflareType.User);
            await _lxdInstanceOperationService.TerminateInstance(instance.Id);
        
            // await Task.Delay(60000);
        
            await _cloudflareDNS.DeleteDNSRecord(instanceId.ToString());
            await _cloudflareTunnel.DeleteCloudflareTunnel(instanceId);
            await _instanceRepository.DeleteInstance(instance.Id);
        }
        else
        {
            _logger.LogInformation("Instance not found");
        }
    }
    public async Task<string> TestInstanceTunnel(string cf_tunnel_id)
    {
        await _cloudflareTunnel.SetCloudflareType(CloudflareType.User);
        string status = await _cloudflareTunnel.TestTunnel(cf_tunnel_id);
        
        _logger.LogInformation(status);
    
        return status;
    }
    public async Task<string> ChangeInstanceState(Instance instance, string state)
    {
        string response = "";
        string lxdUri = "";
        
        _logger.LogInformation("Instance UUID :" + instance.Id);
        
        lxdUri = await _providerServerRepository.GetProviderServerLxdUri(instance.Id);
        
        if(lxdUri != null && lxdUri.Length > 0)
        {
            response = await _lxdInstanceOperationService.ChangeState(instance.Id, state, lxdUri);
    
            switch (state)
            {
                case
                    "start":
                    instance.Status = "Running";
                    break;
                case
                    "stop":
                    instance.Status = "Stopped";
                    break;
                case 
                    "restart":
                    instance.Status = "Restarting";
                    break;
            }
            
            await _instanceRepository.UpdateInstance(instance);
        }
        
        return response;
    }
    public async Task<GetImagesResponse> GetImages(string lxdUri)
    {
        return await _lxdInstanceOperationService.GetImages(lxdUri);
    }
}EOF
--- FILE: Application/Features/Lxd/LxdImages/LxdImageFeatures.cs ---
using SLYD.Application.Interfaces.Features.Lxd.LxdImages;
using SLYD.Application.Interfaces.WebConsole;
using SLYD.Domain.Models;

namespace SLYD.Application.Features.Lxd.LxdImages;

public class LxdImageFeatures : ILxdImageFeatures
{
    private IImageLibraryRepository _imageLibraryRepository;
    
    public LxdImageFeatures(IImageLibraryRepository imageLibraryRepository)
    {
        _imageLibraryRepository = imageLibraryRepository;
    }
    
    public async Task<List<ImageLibrary>> GetImageLibrary()
    {
        return await _imageLibraryRepository.GetImageLibrary();
    }

    public async Task<List<ImageLibraryEndpoint>> GetImageLibraryEndpoints(Guid libraryId)
    {
        return await _imageLibraryRepository.GetImageLibraryEndpoints(libraryId);
    }
}EOF
--- FILE: Application/Features/Lxd/LxdInstance/LxdInstanceFeatures.cs ---
using SLYD.Application.Interfaces.Features.Lxd;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Models;

namespace SLYD.Application.Features.Lxd;

public class LxdInstanceFeatures : ILxdInstanceFeatures
{
    ILxdInstanceOperationService _lxdInstanceOperationService;
    IInstanceRepository _instanceRepository;
    private IProviderServerRepository _providerServerRepository;
    
    public LxdInstanceFeatures(ILxdInstanceOperationService lxdInstanceOperationService, 
        IInstanceRepository instanceRepository, IProviderServerRepository providerServerRepository)
    {
        _lxdInstanceOperationService = lxdInstanceOperationService;
        _instanceRepository = instanceRepository;
        _providerServerRepository = providerServerRepository;
    }
    
    public async Task<string> ChangeState(Guid instanceId, string action)
    {
        string lxdUri = await _providerServerRepository.GetProviderServerLxdUri(instanceId);
        return await _lxdInstanceOperationService.ChangeState(instanceId, action, lxdUri);
    }

    public async Task<string> PostLxdInstance(Instance instance, string tunnel_secret)
    {
        string response = await _lxdInstanceOperationService.PostLxdInstance(instance, tunnel_secret);
        return response;
    }

    public async Task UpdateInstanceInDatabase(Instance instance)
    {
        await _instanceRepository.UpdateInstance(instance);
    }

    public async Task DeleteLxdInstance()
    {
        
    }

    public async Task<Instance> GetInstanceFromDatabase(Guid instanceId)
    {
        return await _instanceRepository.GetInstance(instanceId);
    }
    
    public async Task<string> GetUserPublicKey(Instance instance)
    {
        return await _lxdInstanceOperationService.GetUserPublicKey(instance);
    }
    
    public async Task<string> GetOperation(string lxdUri, string operation)
    {
        return await _lxdInstanceOperationService.GetOperation(lxdUri, operation);
    }

    public async Task AddInstanceEndpoint(Guid instanceId, string dnsRecord, int port)
    {   
        await _instanceRepository.AddInstanceEndpoint(instanceId, dnsRecord, port);
    }
    
    public async Task<string> PostCustomLxdInstance(LxdInstance lxdInstance, Instance instanceDb)
    {
        return await _lxdInstanceOperationService.PostCustomLxdInstance(lxdInstance, instanceDb);
    }
    
    public async Task<string> CloudflareStringBuilder(string tunnelSecret)
    {
        return await _lxdInstanceOperationService.CloudFlareStringBuilder(tunnelSecret);
    }
    
    public async Task<string> AddAuthorizedKeys(string key)
    {
        return await _lxdInstanceOperationService.AddAuthorizedKeys(key);
    }
    
    public async Task<List<Instance>> GetLxdInstancesByCustomer(Guid customerId)
    {
        return await _instanceRepository.GetInstances(customerId);
    }

    public async Task SetInstanceIsDeleting(Guid instanceId)
    {
        await _instanceRepository.SetInstanceIsDeleting(instanceId);
    }
    
    public async Task<string> GetProviderServerLxdUri(Guid instanceId)
    {
        return await _providerServerRepository.GetProviderServerLxdUri(instanceId);
    }
    
    public async Task<Instance> CreateLxdInstanceDb(Instance instance)
    {
        await _instanceRepository.AddInstance(instance);
        return instance;
    }
}EOF
--- FILE: Application/Handlers/LxdInstanceMessageHandler.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdInstanceMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly CreateLxdInstance _createLxdInstance;
    private readonly DeleteLxdInstance _deleteLxdInstance;
    
    public LxdInstanceMessageHandler(ILogger<LxdServerMessageHandler> logger, DeleteLxdInstance deleteLxdInstance,
        CreateLxdInstance createLxdInstance)
    {
        _logger = logger;
        _deleteLxdInstance = deleteLxdInstance;
        _createLxdInstance = createLxdInstance;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdInstanceMessageHandler Received Message");
        Guid instanceId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
            await _createLxdInstance.InitiateInstanceCreation(instanceId);
        }
        else if(message.Action == "CreateCustom")
        {
            await _createLxdInstance.InitiateCustomInstanceCreation(instanceId, message.InstanceJson);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdInstance.DeleteLxdInstanceAsync(instanceId);
        }
    }
}EOF
--- FILE: Application/Handlers/LxdServerMessageHandler.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdServerMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly IAddLxdServer _addLxdServer;
    private readonly DeleteLxdServerPipeline _deleteLxdServerPipeline;
    
    public LxdServerMessageHandler(ILogger<LxdServerMessageHandler> logger, IAddLxdServer addLxdServer,
        DeleteLxdServerPipeline deleteLxdServerPipeline)
    {
        _logger = logger;
        _addLxdServer = addLxdServer;
        _deleteLxdServerPipeline = deleteLxdServerPipeline;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdServerMessageHandler Received Message");
        Guid providerServerId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
           await _addLxdServer.AddServer(providerServerId);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdServerPipeline.DeleteLxdServer(providerServerId);
        }
    }
}EOF
--- FILE: Application/Interfaces/Common/IHttpClientHandlerService.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IHttpClientHandlerService
{
    HttpClient BuildClientHandlerWithCert();
    
    HttpClient BuildClientHandler();

    string GetCertificatePath();
}EOF
--- FILE: Application/Interfaces/Common/IRandomStringGenerator.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IRandomStringGenerator
{
    string GenerateRandomString(int length);
}EOF
--- FILE: Application/Interfaces/Features/Cloudflare/ICloudflareFeatures.cs ---
using System.Net;
using SLYD.Domain.Enums;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features.Cloudflare;

public interface ICloudflareFeatures
{
    Task<bool> InitiateInstanceTunnelConfiguration(string cfd_tunnel_id);
    Task<string> InitiateInstanceTunnelCreation(Guid instanceId);
    Task<string> TestCloudflareConnectivity(string cff_tunnel_id);
    Task<string> InitiateDnsCreation(string cfd_tunnel_id, Guid instanceId);
    Task<string> GetTunnelSecret(string cfd_tunnel_id);
    Task<string> ReconfigureCloudflareTunnel(string cfd_tunnel_id, List<string> endpointList, string dns_record, string subdomain);
    Task<HttpResponseMessage> CreateEndpointDnsRecord(string cfd_tunnel_id, string dns_record);
    Task<HttpResponseMessage> DeleteDnsRecord(Guid id, CloudflareType type);
    Task<HttpResponseMessage> DeleteTunnel(Guid providerServerId);
    Task SetCloudflareType(CloudflareType type);
}EOF
--- FILE: Application/Interfaces/Features/Customer/ICustomerRentalService.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface ICustomerRentalService
{
    Task<List<InstanceRental>> GetRentalsAsync(Guid customerId);
}EOF
--- FILE: Application/Interfaces/Features/Customer/IImageLibraryService.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface IImageLibraryService
{
    Task<List<ImageLibrary>> GetImageLibrary();
    Task<List<ImageLibraryEndpoint>> GetImageLibraryEndpoints(Guid imageLibraryId);
}EOF
--- FILE: Application/Interfaces/Features/Customer/ISearchProvidersService.cs ---
namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface ISearchProvidersService
{
    
}EOF
--- FILE: Application/Interfaces/Features/Customer/Lxd/ICustomerInstance.cs ---
using SLYD.Domain.Models;


namespace SLYD.Application.Interfaces;

public interface ICustomerInstance
{
    Task<Instance> GetInstanceAsync(Guid instanceId);
    Task<List<Instance>> GetInstancesAsync(User user);
    Task<IAsyncResult> DeleteInstanceAsync(Guid instanceId);
}EOF
--- FILE: Application/Interfaces/Features/Customer/Lxd/ILxdInstanceFeatureService.cs ---
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Entities.Lxd.Images;
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerLxd;

public interface ILxdInstanceService
{
    Task<Instance> CreateLxdInstanceAsync(Instance instance);
    Task<List<Instance>> GetLxdInstancesAsync(Guid customerId);
    Task<List<Instance>> GetLxdInstancesIgnoreFiltersAsync(Guid customerId);
    Task DeleteLxdInstanceAsync(Guid instanceId);
    Task<string> TestInstanceTunnel(string UUID);
    Task<string> ChangeInstanceState(Instance instance, string state);
    Task<GetImagesResponse> GetImages(string lxdUri);
    
}EOF
--- FILE: Application/Features/User/UserPublicKeyService.cs ---
using System.Security.Cryptography.X509Certificates;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Application.Interfaces.Features;
using SLYD.Domain.Models;

namespace SLYD.Application.Features;

public class UserPublicKeyService : IUserPublicKeyService
{
    IUserPublicKeyRepository _userPublicKeyRepository;

    public UserPublicKeyService(IUserPublicKeyRepository userPublicKeyRepository)
    {
        _userPublicKeyRepository = userPublicKeyRepository;
    }
    
    public async Task<List<UserPublicKey>> GetPublicKeys(User user)
    {
        return await _userPublicKeyRepository.GetPublicKeys(user);
    }
    
    public async Task<UserPublicKey> GetPublicKey(Guid publicKeyId)
    {
        return await _userPublicKeyRepository.GetPublicKey(publicKeyId);
    }
    
    public async Task<string> SavePublicKey(User user, string publicKey, string name)
    {
        return await _userPublicKeyRepository.SavePublicKey(user, publicKey, name);
        return "";
    }
}EOF
--- FILE: Application/Features/User/UserService.cs ---
using System.Security.Claims;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features.UserService;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Features;

public class UserService : IUserService
{
    private readonly IUserRepostiory _userRepostiory;
    private readonly ILogger _logger;
    public UserService(IUserRepostiory userRepostiory, ILogger<UserService> logger)
    {
        _userRepostiory = userRepostiory;
        _logger = logger;
    }

    public async Task<string> GetUserIdToken(AuthenticationState state)
    {
        string Token = "";
        try
        {
            var claimsPrincipal = state.User;
            
            Token = claimsPrincipal.Claims
                .FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        }
        catch (Exception e)
        {
            _logger.LogError(e.Message);
            throw;
        }
        
        return Token;
    }

    public async Task AddUser(User user)
    {
        await _userRepostiory.AddUser(user);
    }
    
    public async Task AddCustomer(Customer customer)
    {
        await _userRepostiory.AddCustomer(customer);
    }
    
    public async Task AddProvider(Provider provider)
    {
        await _userRepostiory.AddProvider(provider);
    }
    
    public async Task<User?> GetUserAsync(string authId)
    {
        var user = await _userRepostiory.GetUserWithAuthToken(authId);
        return user;
    }
    
    public async Task<Customer?> GetCustomerAsync(Guid userId)
    {
        var customer = await _userRepostiory.GetCustomerWithUserId(userId);
        return customer;
    }
    
    public async Task<Provider?> GetProviderAsync(Guid userId)
    {
        var provider = await _userRepostiory.GetProviderWithUserId(userId);
        return provider;
    }
    
    public async Task DeleteUser(Guid userId)
    {
        await _userRepostiory.DeleteUser(userId);
    }
}EOF
--- FILE: Application/Features/Provider/Server/AddLxdServers.cs ---
using System.Net;
using System.Text.Json;
using SLYD.Domain.Enums;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Entities.Cloudflare;

namespace SLYD.Application.Features;

public class AddLxdServer : IAddLxdServer
{
    private readonly ILogger<IAddLxdServer> _logger;
    private readonly IProviderServerRepository _serverRepository;
    private readonly ICloudflareDNS _cloudflareDns;
    private readonly ICloudflareTunnel _cloudflareTunnel;
    
    public AddLxdServer(ICloudflareTunnel cloudflareTunnel, ICloudflareDNS cloudflareDns, 
        ILogger<IAddLxdServer> logger, IProviderServerRepository serverRepository)
    {
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareDns = cloudflareDns;
        _serverRepository = serverRepository;
        _logger = logger;
    }
    
    public async Task AddServer(Guid serverId)
    {
        try
        {
            _logger.LogInformation("AddLxdServer Received Message");
            
            //Set HttpClient Properties for Management Tunnels
            await _cloudflareTunnel.SetCloudflareType(CloudflareType.Management);
            await _cloudflareDns.SetCloudflareType(CloudflareType.Management);
            
            string cfd_tunnel_id;
            string dns_id;
            bool tunnel_configured;
            string tunnel_secret;
            
            cfd_tunnel_id = await InitiateTunnelCreation(serverId);
            _logger.LogInformation("Tunnel ID: " + cfd_tunnel_id);
            
            dns_id = await InitiateDnsCreation(cfd_tunnel_id, serverId);
            _logger.LogInformation("DNS ID: " + dns_id);
            
            tunnel_secret = await GetTunnelSecret(cfd_tunnel_id);
            _logger.LogInformation("Tunnel Secret: " + tunnel_secret);
            
            tunnel_configured = await InitiateTunnelConfiguration(cfd_tunnel_id);
            _logger.LogInformation("Tunnel Configured: " + tunnel_configured);
            
            if (cfd_tunnel_id.Length > 0 && dns_id.Length > 0 && tunnel_configured)
                await _serverRepository.UpdateProviderServerAsync(serverId, cfd_tunnel_id, dns_id, tunnel_secret);
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
    }
    
    private async Task<string> InitiateTunnelCreation(Guid providerServerId)
    {
        string cfd_tunnel_id = "";

        try
        {
            HttpResponseMessage tunnelResponseMessage = await _cloudflareTunnel.CreateCloudflareTunnel(providerServerId);
            _logger.LogInformation("Tunnel Response: " + await tunnelResponseMessage.Content.ReadAsStringAsync());

            if (tunnelResponseMessage.StatusCode == HttpStatusCode.OK)
            {
                CreateTunnelResponse tunnelResponse =
                    JsonSerializer.Deserialize<CreateTunnelResponse>
                        (await tunnelResponseMessage.Content.ReadAsStringAsync());
                
                cfd_tunnel_id = tunnelResponse.result.id;
            }
            else
            {
                _logger.LogError("Response Does Not Indicate Success : " +
                await tunnelResponseMessage.Content.ReadAsStringAsync());
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.Message);
        }
        
        return cfd_tunnel_id;
    }

    private async Task<string> InitiateDnsCreation(string cfd_tunnel_id, Guid providerServerId)
    {
        string dns_id = "";
        
        if (cfd_tunnel_id.Length > 0)
        {
            HttpResponseMessage response = await _cloudflareDns.CreateDNSRecord(cfd_tunnel_id, providerServerId.ToString());
            _logger.LogInformation("DNS Response: " + await response.Content.ReadAsStringAsync());
            
            if(response.StatusCode == HttpStatusCode.OK)
            {
                DnsApiResponse dnsResponse = JsonSerializer.Deserialize<DnsApiResponse>
                    (await response.Content.ReadAsStringAsync());
                dns_id = dnsResponse.result.id;
            }
            else
            {
                _logger.LogError("Response Does Not Indicate Success : " + await response.Content.ReadAsStringAsync());
            }
        }

        return dns_id;
    }

    public async Task<bool> InitiateTunnelConfiguration(string cfd_tunnel_id)
    {
        HttpResponseMessage message = await _cloudflareTunnel.ConfigureCloudflareTunnel(cfd_tunnel_id, CloudflareType.Management);
        
        if(message.StatusCode == HttpStatusCode.OK)
        {
            _logger.LogInformation("Tunnel Configured Successfully");
            return true;
        }
        else
        {
            _logger.LogError("Response Does Not Indicate Success : " + await message.Content.ReadAsStringAsync());
            return false;
        }
    }
    
    private async Task<string> GetTunnelSecret(string cfd_tunnel_id)
    {
        HttpResponseMessage responseMessage = await _cloudflareTunnel.GetInstallScript(cfd_tunnel_id);
        
        if(responseMessage.StatusCode == HttpStatusCode.OK)
        {
            GetSecretApiResponse apiResponse = JsonSerializer.Deserialize<GetSecretApiResponse>
                (await responseMessage.Content.ReadAsStringAsync());
            
            _logger.LogInformation("Get Install Script:  " + apiResponse.result);

            return apiResponse.result;
        }
        else
        {
            _logger.LogError("Response Does Not Indicate Success : " + await responseMessage.Content.ReadAsStringAsync());
            return "Failed";
        }
    }
}EOF
--- FILE: Application/Features/Provider/Server/InstallScriptFeatures.cs ---
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Interfaces.Infrastructure.Repositories;
using SLYD.Domain.Constants;
using SLYD.Domain.Models.Script;

namespace SLYD.Application.Features;

public class InstallScriptFeatures : IInstallScriptFeatures
{
    private IScriptRepository _scriptRepository;

    public InstallScriptFeatures(IScriptRepository scriptRepository)
    {
        _scriptRepository = scriptRepository;
    }
    
    public async Task<ScriptVersion> GetLatestInstallScript()
    {
        return await _scriptRepository.GetLatestScriptVersionAsync(Guid.Parse(InstallScriptConstants.InstallScriptGuid));
    }
}EOF
--- FILE: Application/Features/Provider/Server/ProviderServerFeatures.cs ---
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Features;

public class ProviderServerFeatures : IProviderServerFeatures
{
    IProviderServerRepository _providerServerRepository;
    private IProviderServerMetricsService _providerServerMetricsService;
    ICloudflareTunnel _cloudflareTunnel;
    ICloudflareDNS _cloudflareDns;
    
    public ProviderServerFeatures(IProviderServerRepository providerServerRepository,
        ICloudflareTunnel cloudflareTunnel, ICloudflareDNS cloudflareDns, IProviderServerMetricsService providerServerMetricsService)
    {
        _providerServerRepository = providerServerRepository;
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareDns = cloudflareDns;
        _providerServerMetricsService = providerServerMetricsService;
    }
    
    public async Task<ProviderServer> AddProviderServer(ProviderServer providerServer)
    {
        return await _providerServerRepository.AddProviderServerAsync(providerServer);
    }
    public async Task<string> GetTunnelSecret(Guid providerServerId)
    {
        var providerServer = await _providerServerRepository.SelectProviderServerAsync(providerServerId);
        return providerServer.TunnelSecret;
    }
    public async Task<string> GetTunnelId(Guid providerServerId)
    {
        var providerServer = await _providerServerRepository.SelectProviderServerAsync(providerServerId);
        return providerServer.CloudflareTunnelId;
    }
    public async Task<List<ProviderServer>> GetAllProviderServers()
    {
        List<ProviderServer> providerServers = await _providerServerRepository.GetProvisionedServersAsync();
        
        return providerServers;
    }
    public async Task<List<ProviderServer>> GetProviderServersAsync(Guid providerServerId)
    {
        List<ProviderServer> providerServers = await _providerServerRepository.GetProviderServersByProviderIdAsync(providerServerId);
        return providerServers;
    }
    
    public async Task<ProviderServer> GetProviderServer(Guid providerServerId)
    {
        ProviderServer providerServer = await _providerServerRepository.SelectProviderServerAsync(providerServerId);
        return providerServer;
    }
    
    public async Task UpdateProviderServer(ProviderServer providerServer)
    {
        await _providerServerRepository.UpdateProviderServerAsync(providerServer);
    }

    public async Task AddProviderServerGpu(ProviderServerGpu gpu)
    {
        await _providerServerRepository.AddProviderServerGpu(gpu);
    }
    
    public async Task<List<ProviderServerGpu>> GetProviderServerGpus(ProviderServer server)
    {
        return await _providerServerRepository.GetProviderServerGpus(server);
    }

    public async Task SetProviderServerPricing(ProviderServerPricing pricing)
    {   
        await _providerServerRepository.SetProviderServerPricing(pricing);
    }
    
    public async Task<List<ProviderServerMetrics>> GetProviderServerMetrics(Guid providerId)
    {
       return await _providerServerRepository.GetProviderServerMetrics(providerId);
    }
    
    public async Task DeleteProviderServer(Guid providerServerId)
    {
      
        await _providerServerRepository.DeleteProviderServerAsync(providerServerId);
    }

    public async Task<HttpResponseMessage> GetDefaultStoragePoolResources(Guid providerServerId)
    {
        string lxdUri = await _providerServerRepository.GetProviderServerLxdUriFromServerId(providerServerId);
        return await _providerServerMetricsService.GetDefaultStoragePoolResources(lxdUri);
    }

    public async Task<HttpResponseMessage> GetDefaultStoragePool(Guid providerServerId)
    {
        string lxdUri = await _providerServerRepository.GetProviderServerLxdUriFromServerId(providerServerId);
        return await _providerServerMetricsService.GetDefaultStoragePool(lxdUri);
    }

    public async Task<HttpResponseMessage> GetResourcesResponse(Guid providerServerId)
    {
        string lxdUri = await _providerServerRepository.GetProviderServerLxdUriFromServerId(providerServerId);
        return await _providerServerMetricsService.GetResourcesResponse(lxdUri);
    }
}EOF
--- FILE: Application/Handlers/LxdInstanceMessageHandlers.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdInstanceMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly CreateLxdInstance _createLxdInstance;
    private readonly DeleteLxdInstance _deleteLxdInstance;
    
    public LxdInstanceMessageHandler(ILogger<LxdServerMessageHandler> logger, DeleteLxdInstance deleteLxdInstance,
        CreateLxdInstance createLxdInstance)
    {
        _logger = logger;
        _deleteLxdInstance = deleteLxdInstance;
        _createLxdInstance = createLxdInstance;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdInstanceMessageHandler Received Message");
        Guid instanceId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
            await _createLxdInstance.InitiateInstanceCreation(instanceId);
        }
        else if(message.Action == "CreateCustom")
        {
            await _createLxdInstance.InitiateCustomInstanceCreation(instanceId, message.InstanceJson);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdInstance.DeleteLxdInstanceAsync(instanceId);
        }
    }
}EOF
--- FILE: Application/Handlers/LxdServerMessageHandlers.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdServerMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly IAddLxdServer _addLxdServer;
    private readonly DeleteLxdServerPipeline _deleteLxdServerPipeline;
    
    public LxdServerMessageHandler(ILogger<LxdServerMessageHandler> logger, IAddLxdServer addLxdServer,
        DeleteLxdServerPipeline deleteLxdServerPipeline)
    {
        _logger = logger;
        _addLxdServer = addLxdServer;
        _deleteLxdServerPipeline = deleteLxdServerPipeline;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdServerMessageHandler Received Message");
        Guid providerServerId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
           await _addLxdServer.AddServer(providerServerId);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdServerPipeline.DeleteLxdServer(providerServerId);
        }
    }
}EOF
--- FILE: Application/Interfaces/Common/IHttpClientHandlerService.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IHttpClientHandlerService
{
    HttpClient BuildClientHandlerWithCert();
    
    HttpClient BuildClientHandler();

    string GetCertificatePath();
}--- FILE: Application/Interfaces/Common/IRandomStringGenerator.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IRandomStringGenerator
{
    string GenerateRandomString(int length);
}EOF
--- FILE: Application/Interfaces/Features/Cloudflare/ICloudflareFeatures.cs ---
using System.Net;
using SLYD.Domain.Enums;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features.Cloudflare;

public interface ICloudflareFeatures
{
    Task<bool> InitiateInstanceTunnelConfiguration(string cfd_tunnel_id);
    Task<string> InitiateInstanceTunnelCreation(Guid instanceId);
    Task<string> TestCloudflareConnectivity(string cff_tunnel_id);
    Task<string> InitiateDnsCreation(string cfd_tunnel_id, Guid instanceId);
    Task<string> GetTunnelSecret(string cfd_tunnel_id);
    Task<string> ReconfigureCloudflareTunnel(string cfd_tunnel_id, List<string> endpointList, string dns_record, string subdomain);
    Task<HttpResponseMessage> CreateEndpointDnsRecord(string cfd_tunnel_id, string dns_record);
    Task<HttpResponseMessage> DeleteDnsRecord(Guid id, CloudflareType type);
    Task<HttpResponseMessage> DeleteTunnel(Guid providerServerId);
    Task SetCloudflareType(CloudflareType type);
}EOF
--- FILE: Application/Interfaces/Features/Customer/ICustomerRentalService.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface ICustomerRentalService
{
    Task<List<InstanceRental>> GetRentalsAsync(Guid customerId);
}EOF
--- FILE: Application/Interfaces/Features/Lxd/LxdImages/LxdImageFeatures.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.Lxd.LxdImages;

public interface ILxdImageFeatures
{
    Task<List<ImageLibrary>> GetImageLibrary();
    Task<List<ImageLibraryEndpoint>> GetImageLibraryEndpoints(Guid libraryId);
}EOF
--- FILE: Application/Interfaces/Features/Lxd/LxdInstance/LxdInstanceFeatures.cs ---
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.Lxd;

public interface ILxdInstanceFeatures
{
    Task<string> ChangeState(Guid instanceId, string action);
    Task<string> PostLxdInstance(Instance instance, string secret);
    Task<string> PostCustomLxdInstance(LxdInstance lxdInstance, Instance instanceDb);
    Task UpdateInstanceInDatabase(Instance instance);
    Task DeleteLxdInstance();
    Task<Instance> GetInstanceFromDatabase(Guid instanceId);
    Task<string> GetUserPublicKey(Instance instance);
    Task<string> GetOperation(string lxdUri, string operation);
    Task AddInstanceEndpoint(Guid instanceId, string dnsRecord, int port);
    Task<string> CloudflareStringBuilder(string tunnelSecret);
    Task<string> AddAuthorizedKeys(string key);
    Task<List<Instance>> GetLxdInstancesByCustomer(Guid customerId);
    Task SetInstanceIsDeleting(Guid instanceId);
    Task<string> GetProviderServerLxdUri(Guid instanceId);
    Task<Instance> CreateLxdInstanceDb(Instance instance);
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/AddLxdServers.cs ---
namespace SLYD.Application.Interfaces.Features;

public interface IAddLxdServer
{
    Task AddServer(Guid serverId);
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/InstallScriptFeatures.cs ---
using SLYD.Domain.Models.Script;

namespace SLYD.Application.Interfaces.Features;

public interface IInstallScriptFeatures
{
    Task<ScriptVersion> GetLatestInstallScript();
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/ProviderServerFeatures.cs ---
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features;

public interface IProviderServerFeatures
{
    Task<ProviderServer> AddProviderServer(ProviderServer providerServer);
    Task<List<ProviderServer>> GetAllProviderServers();
    Task DeleteProviderServer(Guid providerServerId);
    Task<string> GetTunnelSecret(Guid providerServerId);
    Task<string> GetTunnelId(Guid providerServerId);
    Task<List<ProviderServer>> GetProviderServersAsync(Guid providerServerId);
    Task<ProviderServer> GetProviderServer(Guid providerServerId);
    Task UpdateProviderServer(ProviderServer providerServer);
    Task AddProviderServerGpu(ProviderServerGpu gpu);
    Task<List<ProviderServerGpu>> GetProviderServerGpus(ProviderServer server);
    Task SetProviderServerPricing(ProviderServerPricing pricing);
    Task<List<ProviderServerMetrics>> GetProviderServerMetrics(Guid providerId);
    Task<HttpResponseMessage> GetDefaultStoragePoolResources(Guid providerId);
    Task<HttpResponseMessage> GetDefaultStoragePool(Guid providerId);
    
    Task<HttpResponseMessage> GetResourcesResponse(Guid providerId);
    
    
    
}EOF
--- FILE: Application/Interfaces/Features/User/UserPublicKeyService.cs ---

using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features;

public interface IUserPublicKeyService
{
    Task<UserPublicKey> GetPublicKey(Guid publicKeyId);
    Task<List<UserPublicKey>> GetPublicKeys(User user);
    Task<string> SavePublicKey(User user, string publicKey, string name);
}EOF
--- FILE: Application/Interfaces/Features/User/UserService.cs ---
using Microsoft.AspNetCore.Components.Authorization;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features.UserService;

public interface IUserService
{
    Task<string> GetUserIdToken(AuthenticationState state);
    Task AddUser(User user);
    Task<User?> GetUserAsync(string authId);
    Task<Customer?> GetCustomerAsync(Guid userId);
    Task<Provider?> GetProviderAsync(Guid userId);
    Task AddCustomer(Customer customer);
    Task AddProvider(Provider provider);
    Task DeleteUser(Guid userId);
}EOF
--- FILE: Application/Interfaces/Infrastructure/Auth0/Auth0Service.cs ---
using Microsoft.AspNetCore.Components.Authorization;

namespace SLYD.Application.Interfaces.Infrastructure;

public interface IAuth0Service
{
    Task<string> GetUserIdToken(AuthenticationState state);
}EOF
--- FILE: Application/Interfaces/Infrastructure/Auth0/InitialAppState.cs ---
namespace SLYD.Application.Interfaces.Infrastructure;

public class IInitialAppState
{
    public string? IdToken { get; }
    public string? AccessToken { get; }
    public string? RefreshToken { get; }
}EOF
--- FILE: Application/Interfaces/Infrastructure/Auth0/TokenProviders/ITokenProvider.cs ---
namespace SLYD.Application.Interfaces.Infrastructure;

public interface ITokenProvider
{
    public string? IdToken { get; set; }
    public string? AccessToken { get; set; }
    public string? RefreshToken { get; set; }
}EOF
--- FILE: Application/Interfaces/Infrastructure/Cloudflare/ICloudflareDNS.cs ---
using SLYD.Domain.Enums;
using SLYD.Domain.Entities.Cloudflare;

namespace SLYD.Application.Interfaces.Cloudflare;

public interface ICloudflareDNS
{
    Task SetCloudflareType(CloudflareType cloudflareType);
    Task<HttpResponseMessage> CreateDNSRecord(string tunnelId, string dnsRecord);
    Task<HttpResponseMessage> DeleteDNSRecord(string id);
    Task<string> GetZoneId();
}EOF
--- FILE: Application/Interfaces/Infrastructure/Cloudflare/ICloudflareTunnel.cs ---
using SLYD.Domain.Enums;
using SLYD.Domain.Entities.Cloudflare;

namespace SLYD.Application.Interfaces.Cloudflare;

public interface ICloudflareTunnel
{
    Task SetCloudflareType(CloudflareType cloudflareType);
    Task<string> TestTunnel(string cf_tunnel_id);
    Task<HttpResponseMessage> ConfigureCloudflareTunnel(string cf_tunnel_id, CloudflareType cloudflareType);
    Task<string> ReconfigureCloudflareTunnel(string cf_tunnel_id, List<string> services, string hostname,
        string sshHostname);
    Task<string> GetConfiguration(string cf_tunnel_id);
    Task<HttpResponseMessage> DeleteCloudflareTunnel(Guid cloudflareTunnelId);
    Task<HttpResponseMessage> CreateCloudflareTunnel(Guid cloudflareTunnelId);
    Task<HttpResponseMessage> GetInstallScript(string route);
    Task<string> CloudFlareStringBuilder(string secret);
}EOF
--- FILE: Application/Interfaces/Infrastructure/Internal/IScriptSeedService.cs ---
namespace SLYD.Application.Interfaces.Infrastructure.Internal;

public interface IScriptSeedService
{
    Task SeedInstallScript();
}EOF
--- FILE: Application/Interfaces/Infrastructure/Lxd/LxdImages/ILxdImageFeatures.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.Lxd.LxdImages;

public interface ILxdImageFeatures
{
    Task<List<ImageLibrary>> GetImageLibrary();
    Task<List<ImageLibraryEndpoint>> GetImageLibraryEndpoints(Guid libraryId);
}EOF
--- FILE: Application/Interfaces/Infrastructure/Lxd/LxdInstance/ILxdInstanceFeatures.cs ---
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.Lxd;

public interface ILxdInstanceFeatures
{
    Task<string> ChangeState(Guid instanceId, string action);
    Task<string> PostLxdInstance(Instance instance, string secret);
    Task<string> PostCustomLxdInstance(LxdInstance lxdInstance, Instance instanceDb);
    Task UpdateInstanceInDatabase(Instance instance);
    Task DeleteLxdInstance();
    Task<Instance> GetInstanceFromDatabase(Guid instanceId);
    Task<string> GetUserPublicKey(Instance instance);
    Task<string> GetOperation(string lxdUri, string operation);
    Task AddInstanceEndpoint(Guid instanceId, string dnsRecord, int port);
    Task<string> CloudflareStringBuilder(string tunnelSecret);
    Task<string> AddAuthorizedKeys(string key);
    Task<List<Instance>> GetLxdInstancesByCustomer(Guid customerId);
    Task SetInstanceIsDeleting(Guid instanceId);
    Task<string> GetProviderServerLxdUri(Guid instanceId);
    Task<Instance> CreateLxdInstanceDb(Instance instance);
}EOF
--- FILE: Application/Interfaces/Infrastructure/Pipelines/ICreateLxdInstanceService.cs ---
namespace SLYD.Application.Interfaces.Pipelines;

public interface ICreateLxdInstanceService
{
    Task InitiateInstanceCreation(Guid instanceId);
    Task InitiateCustomInstanceCreation(Guid instanceId, string action, string instanceObject);
}EOF
--- FILE: Application/Interfaces/Infrastructure/Pipelines/LxdInstancePipelineService.cs.bak ---
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Entities.Lxd.Images;
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Pipelines;

public interface ILxdInstancePipelineService
{
    Task<string> ChangeState(Guid instanceId, string action, string lxdURI);
    string CloudFlareStringBuilder(string secret);
    Task<string> AddAuthorizedKeys(string key);
    Task<string> TerminateInstance(Guid instanceId);
    Task<string> PostLxdInstance(Instance dbInstance, string secret);
    Task<GetImagesResponse> GetImages(string lxdUri);
    Task<GetImageDetailsResponse> GetImageDetails(string lxdUri);
    Task<string> PostCustomLxdInstance(LxdInstance instance, Instance dbInstance);
    Task<string> GetUserPublicKey(Instance dbInstance);
    Task<string> GetOperation(string lxdUri, string operation);
}EOF
--- FILE: Application/Interfaces/RabbitMQ/MsgHandlers/IMsgHandler.cs ---
namespace SLYD.Application.Interfaces.RabbitMQ;

public interface IMsgHandler<T>
{
    Task HandleMessageAsync(T message);
}EOF
--- FILE: Application/Interfaces/RabbitMQ/RabbitSenderService.cs ---
namespace SLYD.Application.Interfaces.RabbitMQ;

public interface IRabbitSenderService
{
    //LXD Instances
    Task SendCreateInstanceMessage(Guid instanceId);
    Task SendCreateCustomInstanceMessage(Guid instanceId, string instanceJson);
    Task SendDeleteInstanceMessage(Guid instanceId);
    //LXD Server
    Task SendDeleteLxdMessage(Guid providerServerId);
    Task SendCreateLxdTunnelMessage(Guid providerServerId);

}EOF
--- FILE: Application/InternalServices/MessageDispatchers/MessageDispatcher.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Handlers;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Services;

public class MessageDispatcher
{
    private readonly LxdInstanceMessageHandler _lxdInstanceMessageHandler;
    private readonly LxdServerMessageHandler _lxdServerMessageHandler;
    private readonly ILogger<MessageDispatcher> _logger;
    
    public MessageDispatcher(LxdInstanceMessageHandler lxdInstanceMessageHandler, 
        LxdServerMessageHandler lxdServerMessageHandler, ILogger<MessageDispatcher> logger)
    {
        _lxdInstanceMessageHandler = lxdInstanceMessageHandler;
        _lxdServerMessageHandler = lxdServerMessageHandler;
        _logger = logger;
    }
    
    public async Task DispatchAsync(string messageType, RabbitMessage message)
    {
        _logger.LogInformation("Dispatcher Received Message");
        
        try{
            switch (messageType)
            {
                case "LxdInstance":
                    await _lxdInstanceMessageHandler.HandleMessageAsync(message);
                    break;
                case "LxdServer":
                    await _lxdServerMessageHandler.HandleMessageAsync(message);
                    break;
            }
        }
        catch(Exception ex)
        {
            _logger.LogError(ex.ToString());
        }
    }
}EOF
--- FILE: Application/Pipelines/LxdInstance/CreateLxdInstanceService.cs ---
using System.Net;
using System.Text;
using System.Text.Json;
using Domain.Entities.Lxd.Operations;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Entities.Lxd.Instance;
using SLYD.Domain.Enums;
using SLYD.Application.Interfaces.Features.Cloudflare;
using SLYD.Application.Interfaces.Features.Lxd.LxdImages;
using SLYD.Application.Interfaces.Features.Lxd;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Domain.Entities.Cloudflare;
using SLYD.Domain.Models;

namespace SLYD.Application.Pipelines;

public class CreateLxdInstance
{
    ILogger<CreateLxdInstance> _logger;

    private ILxdImageFeatures _lxdImageFeatures;
    private ILxdInstanceFeatures _lxdInstanceFeatures;
    private ICloudflareFeatures _cloudflareFeatures;
    private ILxdInstanceOperationService _lxdInstanceOperationService;
    private ICloudflareTunnel _cloudflareTunnel;
    
    private CloudflareType cloudflareType = CloudflareType.User;
    
    public CreateLxdInstance(ILogger<CreateLxdInstance> logger, ILxdInstanceFeatures lxdInstanceFeatures, 
        ICloudflareFeatures cloudflareFeatures, ILxdImageFeatures lxdImageFeatures, ILxdInstanceOperationService lxdInstanceOperationService, ICloudflareTunnel cloudflareTunnel)
    {
        _lxdInstanceFeatures = lxdInstanceFeatures;
        _lxdImageFeatures = lxdImageFeatures;
        _lxdInstanceOperationService = lxdInstanceOperationService;
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareFeatures = cloudflareFeatures;
        _logger = logger;
    }
    
    public async Task InitiateInstanceCreation(Guid instanceId)
    {
        _logger.LogInformation("Instance Creation Initiated");

        try
        {
            string cfd_tunnel_id;
            string dns_id;
            bool tunnel_configured;
            string tunnel_secret;

            cfd_tunnel_id = await _cloudflareFeatures.InitiateInstanceTunnelCreation(instanceId);
            dns_id = await _cloudflareFeatures.InitiateDnsCreation(cfd_tunnel_id, instanceId);
            tunnel_configured = await _cloudflareFeatures.InitiateInstanceTunnelConfiguration(cfd_tunnel_id);
            tunnel_secret = await _cloudflareFeatures.GetTunnelSecret(cfd_tunnel_id);

            _logger.LogInformation("Tunnel ID: " + cfd_tunnel_id);
            _logger.LogInformation("DNS ID: " + dns_id);
            _logger.LogInformation("Tunnel Configured: " + tunnel_configured);
            _logger.LogInformation("Tunnel Secret: " + tunnel_secret);


            if (cfd_tunnel_id.Length > 0 && dns_id.Length > 0 && tunnel_configured && tunnel_secret != "Failed")
            {
                Instance instance = await _lxdInstanceFeatures.GetInstanceFromDatabase(instanceId);

                if (instance != null)
                {
                    instance.TunnelId = cfd_tunnel_id;
                    instance.DNSId = dns_id;
                    instance.TunnelSecret = tunnel_secret;
                }
                
                await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);

                string response = await _lxdInstanceFeatures.PostLxdInstance(instance, tunnel_secret);
                string lxdUri = await _lxdInstanceFeatures.GetProviderServerLxdUri(instanceId);
                
                PostInstanceResponse postInstanceResponse = JsonSerializer.Deserialize<PostInstanceResponse>(response);

                await CheckInstanceOperation(postInstanceResponse, lxdUri);

                await Task.Delay(1000);
                await _lxdInstanceFeatures.ChangeState(instanceId, "start");

                //Check operation has completed
                bool tunnelActive = await TestInstanceCreation(instanceId);

                if (tunnelActive)
                {
                    _logger.LogInformation("Instance Status Set To Running");
                    instance.Status = "Running";
                    await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                }
                else
                {
                    _logger.LogInformation("Instance Creation Failed");
                }
            }
            else
            {
                _logger.LogError("Instance Creation For Cloudflare Failed");
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
    }

    //Loop to check operation status
    public async Task CheckInstanceOperation(PostInstanceResponse responseMessage, string lxdUri)
    {
        HttpResponseMessage operationResponseMessage = await GetOperation(responseMessage.operation, lxdUri);
        
        if(operationResponseMessage.IsSuccessStatusCode)
        {
            OperationResponse operationResponse = JsonSerializer.Deserialize<OperationResponse>(operationResponseMessage.Content.ReadAsStringAsync().Result);
            
            if(operationResponse.metadata != null && operationResponse.metadata.create_instance_from_image_unpack_progress != null)
            {
                _logger.LogInformation("Progress: " + operationResponse.metadata.create_instance_from_image_unpack_progress);
            }
            await Task.Delay(500);

            while (operationResponseMessage.IsSuccessStatusCode)
            {
                operationResponseMessage = await GetOperation(responseMessage.operation, lxdUri);
            }
        }
    }
    
    public async Task<HttpResponseMessage> GetOperation(string postInstanceResponse, string lxdUri)
    {
        HttpResponseMessage responseMessage = await _lxdInstanceOperationService.GetOperationResponse(lxdUri, postInstanceResponse);

        return responseMessage;
    }

    public async Task InitiateCustomInstanceCreation(Guid instanceId, string instanceObject)
    {
        _logger.LogInformation("Instance Creation Initiated");
        
        try{
            string cfd_tunnel_id;
            string dns_id;
            bool tunnel_configured;
            string tunnel_secret;
            
            cfd_tunnel_id = await _cloudflareFeatures.InitiateInstanceTunnelCreation(instanceId);
            dns_id = await _cloudflareFeatures.InitiateDnsCreation(cfd_tunnel_id, instanceId);
            tunnel_configured = await _cloudflareFeatures.InitiateInstanceTunnelConfiguration(cfd_tunnel_id);
            tunnel_secret = await _cloudflareFeatures.GetTunnelSecret(cfd_tunnel_id);
            
            _logger.LogInformation("Tunnel ID: " + cfd_tunnel_id);
            _logger.LogInformation("DNS ID: " + dns_id);
            _logger.LogInformation("Tunnel Configured: " + tunnel_configured);
            _logger.LogInformation("Tunnel Secret: " + tunnel_secret);
    
            
            if (cfd_tunnel_id.Length > 0 && dns_id.Length > 0 && tunnel_configured && tunnel_secret != "Failed")
            {
                Instance instance = await _lxdInstanceFeatures.GetInstanceFromDatabase(instanceId);
                
                if (instance != null)
                {
                    instance.TunnelId = cfd_tunnel_id;
                    instance.DNSId = dns_id;
                    instance.TunnelSecret = tunnel_secret;
                }

                await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                
                //Configure Instance Endpoints
                await ConfigureInstanceEndpoints(instance, cfd_tunnel_id);
    
                //EXPERIMENTAL
                LxdInstance lxdInstance = JsonSerializer.Deserialize<LxdInstance>(instanceObject);
                
                _logger.LogInformation(instanceObject);
    
                 string key = await _lxdInstanceFeatures.GetUserPublicKey(instance);
                 _logger.LogInformation(key);
                
                 var cloudInitUserData = new StringBuilder();
                 cloudInitUserData.AppendLine("#cloud-config");
                 cloudInitUserData.AppendLine("runcmd:");
                 cloudInitUserData.AppendLine(await _lxdInstanceFeatures.CloudflareStringBuilder(tunnel_secret));
                 cloudInitUserData.AppendLine(await _lxdInstanceFeatures.AddAuthorizedKeys(key));
                
                 lxdInstance.Config = new Config()
                 {
                     CloudInitUserData = cloudInitUserData.ToString()
                 };
                
                string response = await _lxdInstanceFeatures.PostCustomLxdInstance(lxdInstance, instance);
                
                PostInstanceResponse postInstanceResponse = JsonSerializer.Deserialize<PostInstanceResponse>(response);
                
                _logger.LogInformation("Operation: " + postInstanceResponse.operation);
                
                string lxdUri = await _lxdInstanceFeatures.GetProviderServerLxdUri(instanceId);
    
                await Task.Delay(3000);
                string res = await _lxdInstanceFeatures.GetOperation(lxdUri, postInstanceResponse.operation);
                _logger.LogInformation("Raw Response :" + res);
                GetOperation.ApiResponse operationResponse = JsonSerializer.Deserialize<GetOperation.ApiResponse>(res);
                
                _logger.LogInformation("Operation Status: " + operationResponse.status);
                
                if(operationResponse.metadata.metadata.progress.percent != null)
                    _logger.LogInformation("Percent Completed: " + operationResponse.metadata.metadata.progress.percent);
                
                if(operationResponse.metadata.metadata.progress.percent != null)
                {
                    decimal percent = Convert.ToDecimal(operationResponse.metadata.metadata.progress.percent);
                
                    while (percent < 100)
                    {
                        await Task.Delay(3000);
                        GetOperation.ApiResponse retryOperationResponse = 
                            JsonSerializer.Deserialize<GetOperation.ApiResponse>
                                (await _lxdInstanceFeatures.GetOperation(lxdUri, postInstanceResponse.operation));
                
                        if (retryOperationResponse.metadata.metadata.progress.percent != null)
                            percent = Convert.ToDecimal(retryOperationResponse.metadata.metadata.progress.percent);
                        else
                            percent = 100;
                        
                        instance.DeploymentProgress = Convert.ToInt32(percent);
                        await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                        _logger.LogInformation("Percent Completed: " + percent);
                    }
                    
                    _logger.LogInformation("Operation Completed");
                }
    
                await Task.Delay(1000);
                await _lxdInstanceFeatures.ChangeState(instanceId, "start");
               
                //Check operation has completed
                bool tunnelActive = await TestInstanceCreation(instanceId);
    
                if (tunnelActive)
                {
                    _logger.LogInformation("Instance Status Set To Running");
                    instance.Status = "Running";
                    await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                }
                else
                {
                    _logger.LogInformation("Instance Creation Failed");
                }
            }
            else
            {
                _logger.LogError("Instance Creation For Cloudflare Failed");
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
    }
    
    private async Task<bool> TestInstanceCreation(Guid instanceId)
    {
        bool tunnelActive = false;
        
        try{
            _logger.LogInformation("Testing Instance Creation For Cloudflare Tunnel Status");
            int retryCount = 0;
        
            Instance instance = await _lxdInstanceFeatures.GetInstanceFromDatabase(instanceId);

            while (!tunnelActive && retryCount < 10)
            {
                string response = await _lxdInstanceFeatures.ChangeState(instanceId, "start");
                _logger.LogInformation("LXD Response: " + response);
                
                Thread.Sleep(3000);
  
                string tunnelStatus = await _cloudflareFeatures.TestCloudflareConnectivity(instance.TunnelId);
                
                _logger.LogInformation(tunnelStatus);
                
                if(tunnelStatus != null && tunnelStatus == "healthy")
                {    
                    tunnelActive = true;
                    _logger.LogInformation("Tunnel Is Running");
                }
                
                _logger.LogInformation("Tunnel Not Running");
                retryCount++;
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
        
        return tunnelActive;
    }
    
    private async Task<string> ConfigureInstanceEndpoints(Instance instance, string cfd_tunnel_id)
    {
        //Get Template Name
    
        List<ImageLibrary> library = await _lxdImageFeatures.GetImageLibrary();
        
        Guid libraryId = library.Where(l => l.Alias == instance.Alias)
            .Select(l => l.Id).FirstOrDefault();
        
        List<ImageLibraryEndpoint> endpoints = await _lxdImageFeatures.GetImageLibraryEndpoints(libraryId);
        
        List<string> endpointList = new List<string>();
        
        foreach (var endpoint in endpoints)
        {
            endpointList.Add("http://localhost:"+ endpoint.Port);
            
            string dns_record = Guid.NewGuid().ToString() + ".slydtunnels.com";
            
            string dns = await _cloudflareFeatures.ReconfigureCloudflareTunnel(cfd_tunnel_id, endpointList,
                dns_record, instance.Id + ".slydtunnels.com");
            
            HttpResponseMessage response = await _cloudflareFeatures.CreateEndpointDnsRecord(cfd_tunnel_id, dns_record);
            
            _logger.LogInformation("DNS Response: " + await response.Content.ReadAsStringAsync());
            
    
            DnsApiResponse dnsResponse = JsonSerializer.Deserialize<DnsApiResponse>
                (await response.Content.ReadAsStringAsync());
            dns_record = dnsResponse.result.name;
    
    
            await _lxdInstanceFeatures.AddInstanceEndpoint(instance.Id, dns_record, endpoint.Port);
        }
        
        return "";
    }
}EOF
--- FILE: Application/Pipelines/LxdInstance/DeleteLxdInstance.cs ---
using SLYD.Domain.Enums;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models;

namespace SLYD.Application.Pipelines;

public class DeleteLxdInstance
{

    ILogger<DeleteLxdInstance> _logger;
    IInstanceRepository _instanceRepository;
    ICloudflareTunnel _cloudflareTunnel;
    ICloudflareDNS _cloudflareDNS;
    ILxdInstanceOperationService _lxdInstanceOperationService;
    IRentalRepository _rentalRepository;
    
    public DeleteLxdInstance(ILogger<DeleteLxdInstance> logger, IInstanceRepository instanceRepository,
        ICloudflareTunnel cloudflareTunnel, ICloudflareDNS cloudflareDNS,
        IRentalRepository rentalRepository, ILxdInstanceOperationService lxdInstanceOperationService)
    {
        _logger = logger;
        _instanceRepository = instanceRepository;
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareDNS = cloudflareDNS;
        _lxdInstanceOperationService = lxdInstanceOperationService;
        _rentalRepository = rentalRepository;
    }
    public async Task DeleteLxdInstanceAsync(Guid instanceId)
    {
        Instance instance = await _instanceRepository.GetInstance(instanceId);
        
        _logger.LogInformation(instanceId.ToString());
        
        if (instance != null)
        {
            await _cloudflareDNS.SetCloudflareType(CloudflareType.User);
            await _cloudflareTunnel.SetCloudflareType(CloudflareType.User);
            await _lxdInstanceOperationService.TerminateInstance(instanceId);
            
            //REFACTOR
            await _cloudflareDNS.DeleteDNSRecord(instanceId.ToString());
            await _cloudflareTunnel.DeleteCloudflareTunnel(instanceId);
            await _instanceRepository.DeleteInstance(instanceId);
            await _rentalRepository.StopRentalAsync(instanceId);
        }
        else
        {
            _logger.LogInformation("Instance not found");
        }
    }
}EOF
--- FILE: Application/Pipelines/LxdServer/DeleteLxdServerPipeline.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features.Cloudflare;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Enums;

namespace SLYD.Application.Pipelines;

public class DeleteLxdServerPipeline
{
    private readonly ICloudflareFeatures _cloudflareFeatures;
    private readonly ILogger<DeleteLxdServerPipeline> _logger;
    private readonly IProviderServerRepository _providerServerRepository;
    
    public DeleteLxdServerPipeline(IProviderServerRepository providerServerRepository, ICloudflareFeatures cloudflareFeatures,
        ILogger<DeleteLxdServerPipeline> logger)
    {
        _providerServerRepository = providerServerRepository;
        _cloudflareFeatures = cloudflareFeatures;
        _logger = logger;
    }
    
    public async Task DeleteLxdServer(Guid providerServerId)
    {
        try
        {
            _logger.LogInformation("Deleting Lxd Server {providerServerId}", providerServerId);
            var providerServer = await _providerServerRepository.GetProviderServerIgnoreIsDeleted(providerServerId);
            
            await _cloudflareFeatures.SetCloudflareType(CloudflareType.Management);
            
            if(providerServer.CloudflareDnsHostname != null)
                await _cloudflareFeatures.DeleteDnsRecord(providerServerId, CloudflareType.Management);
            
            await Task.Delay(60000);
            
            if(providerServer.CloudflareTunnelId != null)
                await _cloudflareFeatures.DeleteTunnel(providerServerId);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.ToString());
        }
    }
}EOF
--- FILE: Application/User/UserPublicKeyService.cs ---
using System.Security.Cryptography.X509Certificates;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Application.Interfaces.Features;
using SLYD.Domain.Models;

namespace SLYD.Application.Features;

public class UserPublicKeyService : IUserPublicKeyService
{
    IUserPublicKeyRepository _userPublicKeyRepository;

    public UserPublicKeyService(IUserPublicKeyRepository userPublicKeyRepository)
    {
        _userPublicKeyRepository = userPublicKeyRepository;
    }
    
    public async Task<List<UserPublicKey>> GetPublicKeys(User user)
    {
        return await _userPublicKeyRepository.GetPublicKeys(user);
    }
    
    public async Task<UserPublicKey> GetPublicKey(Guid publicKeyId)
    {
        return await _userPublicKeyRepository.GetPublicKey(publicKeyId);
    }
    
    public async Task<string> SavePublicKey(User user, string publicKey, string name)
    {
        return await _userPublicKeyRepository.SavePublicKey(user, publicKey, name);
        return "";
    }
}EOF
--- FILE: Application/User/UserService.cs ---
using System.Security.Claims;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features.UserService;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Features;

public class UserService : IUserService
{
    private readonly IUserRepostiory _userRepostiory;
    private readonly ILogger _logger;
    public UserService(IUserRepostiory userRepostiory, ILogger<UserService> logger)
    {
        _userRepostiory = userRepostiory;
        _logger = logger;
    }

    public async Task<string> GetUserIdToken(AuthenticationState state)
    {
        string Token = "";
        try
        {
            var claimsPrincipal = state.User;
            
            Token = claimsPrincipal.Claims
                .FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        }
        catch (Exception e)
        {
            _logger.LogError(e.Message);
            throw;
        }
        
        return Token;
    }

    public async Task AddUser(User user)
    {
        await _userRepostiory.AddUser(user);
    }
    
    public async Task AddCustomer(Customer customer)
    {
        await _userRepostiory.AddCustomer(customer);
    }
    
    public async Task AddProvider(Provider provider)
    {
        await _userRepostiory.AddProvider(provider);
    }
    
    public async Task<User?> GetUserAsync(string authId)
    {
        var user = await _userRepostiory.GetUserWithAuthToken(authId);
        return user;
    }
    
    public async Task<Customer?> GetCustomerAsync(Guid userId)
    {
        var customer = await _userRepostiory.GetCustomerWithUserId(userId);
        return customer;
    }
    
    public async Task<Provider?> GetProviderAsync(Guid userId)
    {
        var provider = await _userRepostiory.GetProviderWithUserId(userId);
        return provider;
    }
    
    public async Task DeleteUser(Guid userId)
    {
        await _userRepostiory.DeleteUser(userId);
    }
}EOF
--- FILE: Application/Handlers/LxdInstanceMessageHandlers.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdInstanceMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly CreateLxdInstance _createLxdInstance;
    private readonly DeleteLxdInstance _deleteLxdInstance;
    
    public LxdInstanceMessageHandler(ILogger<LxdServerMessageHandler> logger, DeleteLxdInstance deleteLxdInstance,
        CreateLxdInstance createLxdInstance)
    {
        _logger = logger;
        _deleteLxdInstance = deleteLxdInstance;
        _createLxdInstance = createLxdInstance;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdInstanceMessageHandler Received Message");
        Guid instanceId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
            await _createLxdInstance.InitiateInstanceCreation(instanceId);
        }
        else if(message.Action == "CreateCustom")
        {
            await _createLxdInstance.InitiateCustomInstanceCreation(instanceId, message.InstanceJson);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdInstance.DeleteLxdInstanceAsync(instanceId);
        }
    }
}EOF
--- FILE: Application/Handlers/LxdServerMessageHandlers.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdServerMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly IAddLxdServer _addLxdServer;
    private readonly DeleteLxdServerPipeline _deleteLxdServerPipeline;
    
    public LxdServerMessageHandler(ILogger<LxdServerMessageHandler> logger, IAddLxdServer addLxdServer,
        DeleteLxdServerPipeline deleteLxdServerPipeline)
    {
        _logger = logger;
        _addLxdServer = addLxdServer;
        _deleteLxdServerPipeline = deleteLxdServerPipeline;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdServerMessageHandler Received Message");
        Guid providerServerId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
           await _addLxdServer.AddServer(providerServerId);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdServerPipeline.DeleteLxdServer(providerServerId);
        }
    }
}EOF
--- FILE: Application/Interfaces/Common/IHttpClientHandlerService.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IHttpClientHandlerService
{
    HttpClient BuildClientHandlerWithCert();
    
    HttpClient BuildClientHandler();

    string GetCertificatePath();
}EOF
--- FILE: Application/Interfaces/Common/IRandomStringGenerator.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IRandomStringGenerator
{
    string GenerateRandomString(int length);
}EOF
--- FILE: Application/Interfaces/Features/Cloudflare/ICloudflareFeatures.cs ---
using System.Net;
using SLYD.Domain.Enums;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features.Cloudflare;

public interface ICloudflareFeatures
{
    Task<bool> InitiateInstanceTunnelConfiguration(string cfd_tunnel_id);
    Task<string> InitiateInstanceTunnelCreation(Guid instanceId);
    Task<string> TestCloudflareConnectivity(string cff_tunnel_id);
    Task<string> InitiateDnsCreation(string cfd_tunnel_id, Guid instanceId);
    Task<string> GetTunnelSecret(string cfd_tunnel_id);
    Task<string> ReconfigureCloudflareTunnel(string cfd_tunnel_id, List<string> endpointList, string dns_record, string subdomain);
    Task<HttpResponseMessage> CreateEndpointDnsRecord(string cfd_tunnel_id, string dns_record);
    Task<HttpResponseMessage> DeleteDnsRecord(Guid id, CloudflareType type);
    Task<HttpResponseMessage> DeleteTunnel(Guid providerServerId);
    Task SetCloudflareType(CloudflareType type);
}EOF
--- FILE: Application/Interfaces/Features/Customer/ICustomerRentalService.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface ICustomerRentalService
{
    Task<List<InstanceRental>> GetRentalsAsync(Guid customerId);
}EOF
--- FILE: Application/Interfaces/Features/Customer/IImageLibraryService.cs ---
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface IImageLibraryService
{
    Task<List<ImageLibrary>> GetImageLibrary();
    Task<List<ImageLibraryEndpoint>> GetImageLibraryEndpoints(Guid imageLibraryId);
}EOF
--- FILE: Application/Interfaces/Features/Customer/ISearchProvidersService.cs ---
namespace SLYD.Application.Interfaces.Features.CustomerFeature;

public interface ISearchProvidersService
{
    
}EOF
--- FILE: Application/Interfaces/Features/Customer/Lxd/ICustomerInstance.cs ---
using SLYD.Domain.Models;


namespace SLYD.Application.Interfaces;

public interface ICustomerInstance
{
    Task<Instance> GetInstanceAsync(Guid instanceId);
    Task<List<Instance>> GetInstancesAsync(User user);
    Task<IAsyncResult> DeleteInstanceAsync(Guid instanceId);
}EOF
--- FILE: Application/Interfaces/Features/Customer/Lxd/ILxdInstanceFeatureService.cs ---
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Entities.Lxd.Images;
using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features.CustomerLxd;

public interface ILxdInstanceService
{
    Task<Instance> CreateLxdInstanceAsync(Instance instance);
    Task<List<Instance>> GetLxdInstancesAsync(Guid customerId);
    Task<List<Instance>> GetLxdInstancesIgnoreFiltersAsync(Guid customerId);
    Task DeleteLxdInstanceAsync(Guid instanceId);
    Task<string> TestInstanceTunnel(string UUID);
    Task<string> ChangeInstanceState(Instance instance, string state);
    Task<GetImagesResponse> GetImages(string lxdUri);
    
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/InstallScriptFeatures.cs ---
using SLYD.Domain.Models.Script;

namespace SLYD.Application.Interfaces.Features;

public interface IInstallScriptFeatures
{
    Task<ScriptVersion> GetLatestInstallScript();
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/ProviderServerFeatures.cs ---
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features;

public interface IProviderServerFeatures
{
    Task<ProviderServer> AddProviderServer(ProviderServer providerServer);
    Task<List<ProviderServer>> GetAllProviderServers();
    Task DeleteProviderServer(Guid providerServerId);
    Task<string> GetTunnelSecret(Guid providerServerId);
    Task<string> GetTunnelId(Guid providerServerId);
    Task<List<ProviderServer>> GetProviderServersAsync(Guid providerServerId);
    Task<ProviderServer> GetProviderServer(Guid providerServerId);
    Task UpdateProviderServer(ProviderServer providerServer);
    Task AddProviderServerGpu(ProviderServerGpu gpu);
    Task<List<ProviderServerGpu>> GetProviderServerGpus(ProviderServer server);
    Task SetProviderServerPricing(ProviderServerPricing pricing);
    Task<List<ProviderServerMetrics>> GetProviderServerMetrics(Guid providerId);
    Task<HttpResponseMessage> GetDefaultStoragePoolResources(Guid providerId);
    Task<HttpResponseMessage> GetDefaultStoragePool(Guid providerId);
    
    Task<HttpResponseMessage> GetResourcesResponse(Guid providerId);
    
    
    
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/User/IUserPublicKeyService.cs ---

using SLYD.Domain.Models;

namespace SLYD.Application.Interfaces.Features;

public interface IUserPublicKeyService
{
    Task<UserPublicKey> GetPublicKey(Guid publicKeyId);
    Task<List<UserPublicKey>> GetPublicKeys(User user);
    Task<string> SavePublicKey(User user, string publicKey, string name);
}EOF
--- FILE: Application/Interfaces/Features/Provider/Server/User/IUserService.cs ---
using Microsoft.AspNetCore.Components.Authorization;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features.UserService;

public interface IUserService
{
    Task<string> GetUserIdToken(AuthenticationState state);
    Task AddUser(User user);
    Task<User?> GetUserAsync(string authId);
    Task<Customer?> GetCustomerAsync(Guid userId);
    Task<Provider?> GetProviderAsync(Guid userId);
    Task AddCustomer(Customer customer);
    Task AddProvider(Provider provider);
    Task DeleteUser(Guid userId);
}EOF
--- FILE: Application/Interfaces/Features/Cloudflare/ICloudflareFeatures.cs ---
using System.Net;
using SLYD.Domain.Enums;
using SLYD.Domain.Models;
using SLYD.Domain.Models.ProviderModels;

namespace SLYD.Application.Interfaces.Features.Cloudflare;

public interface ICloudflareFeatures
{
    Task<bool> InitiateInstanceTunnelConfiguration(string cfd_tunnel_id);
    Task<string> InitiateInstanceTunnelCreation(Guid instanceId);
    Task<string> TestCloudflareConnectivity(string cff_tunnel_id);
    Task<string> InitiateDnsCreation(string cfd_tunnel_id, Guid instanceId);
    Task<string> GetTunnelSecret(string cfd_tunnel_id);
    Task<string> ReconfigureCloudflareTunnel(string cfd_tunnel_id, List<string> endpointList, string dns_record, string subdomain);
    Task<HttpResponseMessage> CreateEndpointDnsRecord(string cfd_tunnel_id, string dns_record);
    Task<HttpResponseMessage> DeleteDnsRecord(Guid id, CloudflareType type);
    Task<HttpResponseMessage> DeleteTunnel(Guid providerServerId);
    Task SetCloudflareType(CloudflareType type);
}EOF
--- FILE: Application/Interfaces/Common/IHttpClientHandlerService.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IHttpClientHandlerService
{
    HttpClient BuildClientHandlerWithCert();
    
    HttpClient BuildClientHandler();

    string GetCertificatePath();
}EOF
--- FILE: Application/Interfaces/Common/IRandomStringGenerator.cs ---
namespace SLYD.Application.Interfaces.Common;

public interface IRandomStringGenerator
{
    string GenerateRandomString(int length);
}EOF
--- FILE: Application/Interfaces/Handlers/LxdInstanceMessageHandler.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdInstanceMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly CreateLxdInstance _createLxdInstance;
    private readonly DeleteLxdInstance _deleteLxdInstance;
    
    public LxdInstanceMessageHandler(ILogger<LxdServerMessageHandler> logger, DeleteLxdInstance deleteLxdInstance,
        CreateLxdInstance createLxdInstance)
    {
        _logger = logger;
        _deleteLxdInstance = deleteLxdInstance;
        _createLxdInstance = createLxdInstance;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdInstanceMessageHandler Received Message");
        Guid instanceId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
            await _createLxdInstance.InitiateInstanceCreation(instanceId);
        }
        else if(message.Action == "CreateCustom")
        {
            await _createLxdInstance.InitiateCustomInstanceCreation(instanceId, message.InstanceJson);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdInstance.DeleteLxdInstanceAsync(instanceId);
        }
    }
}EOF
--- FILE: Application/Interfaces/Handlers/LxdServerMessageHandler.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Features;
using SLYD.Application.Pipelines;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Handlers;

public class LxdServerMessageHandler
{
    private readonly ILogger<LxdServerMessageHandler> _logger;
    private readonly IAddLxdServer _addLxdServer;
    private readonly DeleteLxdServerPipeline _deleteLxdServerPipeline;
    
    public LxdServerMessageHandler(ILogger<LxdServerMessageHandler> logger, IAddLxdServer addLxdServer,
        DeleteLxdServerPipeline deleteLxdServerPipeline)
    {
        _logger = logger;
        _addLxdServer = addLxdServer;
        _deleteLxdServerPipeline = deleteLxdServerPipeline;
    }
    
    public async Task HandleMessageAsync(RabbitMessage message)
    {
        _logger.LogInformation("LxdServerMessageHandler Received Message");
        Guid providerServerId = Guid.Parse(message.UUID);
        
        if (message.Action == "Create")
        {
           await _addLxdServer.AddServer(providerServerId);
        }
        else if (message.Action == "Delete")
        {
            await _deleteLxdServerPipeline.DeleteLxdServer(providerServerId);
        }
    }
}EOF
--- FILE: Application/InternalServices/MessageDispatcher.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Handlers;
using SLYD.Domain.Entities.RabbitMQ;

namespace SLYD.Application.Services;

public class MessageDispatcher
{
    private readonly LxdInstanceMessageHandler _lxdInstanceMessageHandler;
    private readonly LxdServerMessageHandler _lxdServerMessageHandler;
    private readonly ILogger<MessageDispatcher> _logger;
    
    public MessageDispatcher(LxdInstanceMessageHandler lxdInstanceMessageHandler, 
        LxdServerMessageHandler lxdServerMessageHandler, ILogger<MessageDispatcher> logger)
    {
        _lxdInstanceMessageHandler = lxdInstanceMessageHandler;
        _lxdServerMessageHandler = lxdServerMessageHandler;
        _logger = logger;
    }
    
    public async Task DispatchAsync(string messageType, RabbitMessage message)
    {
        _logger.LogInformation("Dispatcher Received Message");
        
        try{
            switch (messageType)
            {
                case "LxdInstance":
                    await _lxdInstanceMessageHandler.HandleMessageAsync(message);
                    break;
                case "LxdServer":
                    await _lxdServerMessageHandler.HandleMessageAsync(message);
                    break;
            }
        }
        catch(Exception ex)
        {
            _logger.LogError(ex.ToString());
        }
    }
}EOF
--- FILE: Application/Pipelines/LxdInstance/CreateLxdInstanceService.cs ---
using System.Net;
using System.Text;
using System.Text.Json;
using Domain.Entities.Lxd.Operations;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Domain.Entities.Lxd;
using SLYD.Domain.Entities.Lxd.Instance;
using SLYD.Domain.Enums;
using SLYD.Application.Interfaces.Features.Cloudflare;
using SLYD.Application.Interfaces.Features.Lxd.LxdImages;
using SLYD.Application.Interfaces.Features.Lxd;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Domain.Entities.Cloudflare;
using SLYD.Domain.Models;

namespace SLYD.Application.Pipelines;

public class CreateLxdInstance
{
    ILogger<CreateLxdInstance> _logger;

    private ILxdImageFeatures _lxdImageFeatures;
    private ILxdInstanceFeatures _lxdInstanceFeatures;
    private ICloudflareFeatures _cloudflareFeatures;
    private ILxdInstanceOperationService _lxdInstanceOperationService;
    private ICloudflareTunnel _cloudflareTunnel;
    
    private CloudflareType cloudflareType = CloudflareType.User;
    
    public CreateLxdInstance(ILogger<CreateLxdInstance> logger, ILxdInstanceFeatures lxdInstanceFeatures, 
        ICloudflareFeatures cloudflareFeatures, ILxdImageFeatures lxdImageFeatures, ILxdInstanceOperationService lxdInstanceOperationService, ICloudflareTunnel cloudflareTunnel)
    {
        _lxdInstanceFeatures = lxdInstanceFeatures;
        _lxdImageFeatures = lxdImageFeatures;
        _lxdInstanceOperationService = lxdInstanceOperationService;
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareFeatures = cloudflareFeatures;
        _logger = logger;
    }
    
    public async Task InitiateInstanceCreation(Guid instanceId)
    {
        _logger.LogInformation("Instance Creation Initiated");

        try
        {
            string cfd_tunnel_id;
            string dns_id;
            bool tunnel_configured;
            string tunnel_secret;

            cfd_tunnel_id = await _cloudflareFeatures.InitiateInstanceTunnelCreation(instanceId);
            dns_id = await _cloudflareFeatures.InitiateDnsCreation(cfd_tunnel_id, instanceId);
            tunnel_configured = await _cloudflareFeatures.InitiateInstanceTunnelConfiguration(cfd_tunnel_id);
            tunnel_secret = await _cloudflareFeatures.GetTunnelSecret(cfd_tunnel_id);

            _logger.LogInformation("Tunnel ID: " + cfd_tunnel_id);
            _logger.LogInformation("DNS ID: " + dns_id);
            _logger.LogInformation("Tunnel Configured: " + tunnel_configured);
            _logger.LogInformation("Tunnel Secret: " + tunnel_secret);


            if (cfd_tunnel_id.Length > 0 && dns_id.Length > 0 && tunnel_configured && tunnel_secret != "Failed")
            {
                Instance instance = await _lxdInstanceFeatures.GetInstanceFromDatabase(instanceId);

                if (instance != null)
                {
                    instance.TunnelId = cfd_tunnel_id;
                    instance.DNSId = dns_id;
                    instance.TunnelSecret = tunnel_secret;
                }
                
                await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);

                string response = await _lxdInstanceFeatures.PostLxdInstance(instance, tunnel_secret);
                string lxdUri = await _lxdInstanceFeatures.GetProviderServerLxdUri(instanceId);
                
                PostInstanceResponse postInstanceResponse = JsonSerializer.Deserialize<PostInstanceResponse>(response);

                await CheckInstanceOperation(postInstanceResponse, lxdUri);

                await Task.Delay(1000);
                await _lxdInstanceFeatures.ChangeState(instanceId, "start");

                //Check operation has completed
                bool tunnelActive = await TestInstanceCreation(instanceId);

                if (tunnelActive)
                {
                    _logger.LogInformation("Instance Status Set To Running");
                    instance.Status = "Running";
                    await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                }
                else
                {
                    _logger.LogInformation("Instance Creation Failed");
                }
            }
            else
            {
                _logger.LogError("Instance Creation For Cloudflare Failed");
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
    }

    //Loop to check operation status
    public async Task CheckInstanceOperation(PostInstanceResponse responseMessage, string lxdUri)
    {
        HttpResponseMessage operationResponseMessage = await GetOperation(responseMessage.operation, lxdUri);
        
        if(operationResponseMessage.IsSuccessStatusCode)
        {
            OperationResponse operationResponse = JsonSerializer.Deserialize<OperationResponse>(operationResponseMessage.Content.ReadAsStringAsync().Result);
            
            if(operationResponse.metadata != null && operationResponse.metadata.create_instance_from_image_unpack_progress != null)
            {
                _logger.LogInformation("Progress: " + operationResponse.metadata.create_instance_from_image_unpack_progress);
            }
            await Task.Delay(500);

            while (operationResponseMessage.IsSuccessStatusCode)
            {
                operationResponseMessage = await GetOperation(responseMessage.operation, lxdUri);
            }
        }
    }
    
    public async Task<HttpResponseMessage> GetOperation(string postInstanceResponse, string lxdUri)
    {
        HttpResponseMessage responseMessage = await _lxdInstanceOperationService.GetOperationResponse(lxdUri, postInstanceResponse);

        return responseMessage;
    }

    public async Task InitiateCustomInstanceCreation(Guid instanceId, string instanceObject)
    {
        _logger.LogInformation("Instance Creation Initiated");
        
        try{
            string cfd_tunnel_id;
            string dns_id;
            bool tunnel_configured;
            string tunnel_secret;
            
            cfd_tunnel_id = await _cloudflareFeatures.InitiateInstanceTunnelCreation(instanceId);
            dns_id = await _cloudflareFeatures.InitiateDnsCreation(cfd_tunnel_id, instanceId);
            tunnel_configured = await _cloudflareFeatures.InitiateInstanceTunnelConfiguration(cfd_tunnel_id);
            tunnel_secret = await _cloudflareFeatures.GetTunnelSecret(cfd_tunnel_id);
            
            _logger.LogInformation("Tunnel ID: " + cfd_tunnel_id);
            _logger.LogInformation("DNS ID: " + dns_id);
            _logger.LogInformation("Tunnel Configured: " + tunnel_configured);
            _logger.LogInformation("Tunnel Secret: " + tunnel_secret);
    
            
            if (cfd_tunnel_id.Length > 0 && dns_id.Length > 0 && tunnel_configured && tunnel_secret != "Failed")
            {
                Instance instance = await _lxdInstanceFeatures.GetInstanceFromDatabase(instanceId);
                
                if (instance != null)
                {
                    instance.TunnelId = cfd_tunnel_id;
                    instance.DNSId = dns_id;
                    instance.TunnelSecret = tunnel_secret;
                }

                await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                
                //Configure Instance Endpoints
                await ConfigureInstanceEndpoints(instance, cfd_tunnel_id);
    
                //EXPERIMENTAL
                LxdInstance lxdInstance = JsonSerializer.Deserialize<LxdInstance>(instanceObject);
                
                _logger.LogInformation(instanceObject);
    
                 string key = await _lxdInstanceFeatures.GetUserPublicKey(instance);
                 _logger.LogInformation(key);
                
                 var cloudInitUserData = new StringBuilder();
                 cloudInitUserData.AppendLine("#cloud-config");
                 cloudInitUserData.AppendLine("runcmd:");
                 cloudInitUserData.AppendLine(await _lxdInstanceFeatures.CloudflareStringBuilder(tunnel_secret));
                 cloudInitUserData.AppendLine(await _lxdInstanceFeatures.AddAuthorizedKeys(key));
                
                 lxdInstance.Config = new Config()
                 {
                     CloudInitUserData = cloudInitUserData.ToString()
                 };
                
                string response = await _lxdInstanceFeatures.PostCustomLxdInstance(lxdInstance, instance);
                
                PostInstanceResponse postInstanceResponse = JsonSerializer.Deserialize<PostInstanceResponse>(response);
                
                _logger.LogInformation("Operation: " + postInstanceResponse.operation);
                
                string lxdUri = await _lxdInstanceFeatures.GetProviderServerLxdUri(instanceId);
    
                await Task.Delay(3000);
                string res = await _lxdInstanceFeatures.GetOperation(lxdUri, postInstanceResponse.operation);
                _logger.LogInformation("Raw Response :" + res);
                GetOperation.ApiResponse operationResponse = JsonSerializer.Deserialize<GetOperation.ApiResponse>(res);
                
                _logger.LogInformation("Operation Status: " + operationResponse.status);
                
                if(operationResponse.metadata.metadata.progress.percent != null)
                    _logger.LogInformation("Percent Completed: " + operationResponse.metadata.metadata.progress.percent);
                
                if(operationResponse.metadata.metadata.progress.percent != null)
                {
                    decimal percent = Convert.ToDecimal(operationResponse.metadata.metadata.progress.percent);
                
                    while (percent < 100)
                    {
                        await Task.Delay(3000);
                        GetOperation.ApiResponse retryOperationResponse = 
                            JsonSerializer.Deserialize<GetOperation.ApiResponse>
                                (await _lxdInstanceFeatures.GetOperation(lxdUri, postInstanceResponse.operation));
                
                        if (retryOperationResponse.metadata.metadata.progress.percent != null)
                            percent = Convert.ToDecimal(retryOperationResponse.metadata.metadata.progress.percent);
                        else
                            percent = 100;
                        
                        instance.DeploymentProgress = Convert.ToInt32(percent);
                        await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                        _logger.LogInformation("Percent Completed: " + percent);
                    }
                    
                    _logger.LogInformation("Operation Completed");
                }
    
                await Task.Delay(1000);
                await _lxdInstanceFeatures.ChangeState(instanceId, "start");
               
                //Check operation has completed
                bool tunnelActive = await TestInstanceCreation(instanceId);
    
                if (tunnelActive)
                {
                    _logger.LogInformation("Instance Status Set To Running");
                    instance.Status = "Running";
                    await _lxdInstanceFeatures.UpdateInstanceInDatabase(instance);
                }
                else
                {
                    _logger.LogInformation("Instance Creation Failed");
                }
            }
            else
            {
                _logger.LogError("Instance Creation For Cloudflare Failed");
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
    }
    
    private async Task<bool> TestInstanceCreation(Guid instanceId)
    {
        bool tunnelActive = false;
        
        try{
            _logger.LogInformation("Testing Instance Creation For Cloudflare Tunnel Status");
            int retryCount = 0;
        
            Instance instance = await _lxdInstanceFeatures.GetInstanceFromDatabase(instanceId);

            while (!tunnelActive && retryCount < 10)
            {
                string response = await _lxdInstanceFeatures.ChangeState(instanceId, "start");
                _logger.LogInformation("LXD Response: " + response);
                
                Thread.Sleep(3000);
  
                string tunnelStatus = await _cloudflareFeatures.TestCloudflareConnectivity(instance.TunnelId);
                
                _logger.LogInformation(tunnelStatus);
                
                if(tunnelStatus != null && tunnelStatus == "healthy")
                {    
                    tunnelActive = true;
                    _logger.LogInformation("Tunnel Is Running");
                }
                
                _logger.LogInformation("Tunnel Not Running");
                retryCount++;
            }
        }
        catch (Exception e)
        {
            _logger.LogError(e.ToString());
        }
        
        return tunnelActive;
    }
    
    private async Task<string> ConfigureInstanceEndpoints(Instance instance, string cfd_tunnel_id)
    {
        //Get Template Name
    
        List<ImageLibrary> library = await _lxdImageFeatures.GetImageLibrary();
        
        Guid libraryId = library.Where(l => l.Alias == instance.Alias)
            .Select(l => l.Id).FirstOrDefault();
        
        List<ImageLibraryEndpoint> endpoints = await _lxdImageFeatures.GetImageLibraryEndpoints(libraryId);
        
        List<string> endpointList = new List<string>();
        
        foreach (var endpoint in endpoints)
        {
            endpointList.Add("http://localhost:"+ endpoint.Port);
            
            string dns_record = Guid.NewGuid().ToString() + ".slydtunnels.com";
            
            string dns = await _cloudflareFeatures.ReconfigureCloudflareTunnel(cfd_tunnel_id, endpointList,
                dns_record, instance.Id + ".slydtunnels.com");
            
            HttpResponseMessage response = await _cloudflareFeatures.CreateEndpointDnsRecord(cfd_tunnel_id, dns_record);
            
            _logger.LogInformation("DNS Response: " + await response.Content.ReadAsStringAsync());
            
    
            DnsApiResponse dnsResponse = JsonSerializer.Deserialize<DnsApiResponse>
                (await response.Content.ReadAsStringAsync());
            dns_record = dnsResponse.result.name;
    
    
            await _lxdInstanceFeatures.AddInstanceEndpoint(instance.Id, dns_record, endpoint.Port);
        }
        
        return "";
    }
}EOF
--- FILE: Application/Pipelines/LxdInstance/DeleteLxdInstance.cs ---
using SLYD.Domain.Enums;
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Infrastructure.Lxd;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models;

namespace SLYD.Application.Pipelines;

public class DeleteLxdInstance
{

    ILogger<DeleteLxdInstance> _logger;
    IInstanceRepository _instanceRepository;
    ICloudflareTunnel _cloudflareTunnel;
    ICloudflareDNS _cloudflareDNS;
    ILxdInstanceOperationService _lxdInstanceOperationService;
    IRentalRepository _rentalRepository;
    
    public DeleteLxdInstance(ILogger<DeleteLxdInstance> logger, IInstanceRepository instanceRepository,
        ICloudflareTunnel cloudflareTunnel, ICloudflareDNS cloudflareDNS,
        IRentalRepository rentalRepository, ILxdInstanceOperationService lxdInstanceOperationService)
    {
        _logger = logger;
        _instanceRepository = instanceRepository;
        _cloudflareTunnel = cloudflareTunnel;
        _cloudflareDNS = cloudflareDNS;
        _lxdInstanceOperationService = lxdInstanceOperationService;
        _rentalRepository = rentalRepository;
    }
    public async Task DeleteLxdInstanceAsync(Guid instanceId)
    {
        Instance instance = await _instanceRepository.GetInstance(instanceId);
        
        _logger.LogInformation(instanceId.ToString());
        
        if (instance != null)
        {
            await _cloudflareDNS.SetCloudflareType(CloudflareType.User);
            await _cloudflareTunnel.SetCloudflareType(CloudflareType.User);
            await _lxdInstanceOperationService.TerminateInstance(instanceId);
            
            //REFACTOR
            await _cloudflareDNS.DeleteDNSRecord(instanceId.ToString());
            await _cloudflareTunnel.DeleteCloudflareTunnel(instanceId);
            await _instanceRepository.DeleteInstance(instanceId);
            await _rentalRepository.StopRentalAsync(instanceId);
        }
        else
        {
            _logger.LogInformation("Instance not found");
        }
    }
EOF
}--- FILE: Application/Pipelines/LxdServer/DeleteLxdServerPipeline.cs ---
using Microsoft.Extensions.Logging;
using SLYD.Application.Interfaces.Cloudflare;
using SLYD.Application.Interfaces.Features.Cloudflare;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Enums;

namespace SLYD.Application.Pipelines;

public class DeleteLxdServerPipeline
{
    private readonly ICloudflareFeatures _cloudflareFeatures;
    private readonly ILogger<DeleteLxdServerPipeline> _logger;
    private readonly IProviderServerRepository _providerServerRepository;
    
    public DeleteLxdServerPipeline(IProviderServerRepository providerServerRepository, ICloudflareFeatures cloudflareFeatures,
        ILogger<DeleteLxdServerPipeline> logger)
    {
        _providerServerRepository = providerServerRepository;
        _cloudflareFeatures = cloudflareFeatures;
        _logger = logger;
    }
    
    public async Task DeleteLxdServer(Guid providerServerId)
    {
        try
        {
            _logger.LogInformation("Deleting Lxd Server {providerServerId}", providerServerId);
            var providerServer = await _providerServerRepository.GetProviderServerIgnoreIsDeleted(providerServerId);
            
            await _cloudflareFeatures.SetCloudflareType(CloudflareType.Management);
            
            if(providerServer.CloudflareDnsHostname != null)
                await _cloudflareFeatures.DeleteDnsRecord(providerServerId, CloudflareType.Management);
            
            await Task.Delay(60000);
            
            if(providerServer.CloudflareTunnelId != null)
                await _cloudflareFeatures.DeleteTunnel(providerServerId);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.ToString());
        }
    }
}EOF
--- FILE: Domain/Constants/InstallScriptConstants.cs ---
namespace SLYD.Domain.Constants;

public static class InstallScriptConstants
{
    public const string InstallScriptGuid = "5730c322-f15d-47e5-a9b5-4fd9096b5f06";
}EOF
--- FILE: Domain/Entities/Cloudflare/CreateConfig.cs ---
using System.Text.Json.Serialization;

namespace SLYD.Domain.Entities.Cloudflare;

public class CreateConfig
{
    [JsonPropertyName("config")]
    public CloudflareConfig config { get; set; }
}
    
public class CloudflareConfig
{
    public OriginRequest originRequest { get; set; }
    public WarpRouting warpRouting { get; set; }
    public List<Ingress> ingress { get; set; }
}

public class OriginRequest
{
    public bool noTLSVerify { get; set; }
}

public class WarpRouting
{
    public bool enabled { get; set; }
}

public class Ingress
{
    public string hostname { get; set; }
    public string service { get; set; }
}EOF
--- FILE: Domain/Entities/Cloudflare/CreateTunnelBody.cs ---
namespace SLYD.Domain.Entities.Cloudflare;

public class CreateTunnelBody
{
    public class BodyContent
    {
        public string name { get; set; }
        public string tunnel_secret { get; set; }
    }
}EOF
--- FILE: Domain/Entities/Cloudflare/CreateTunnelResponse.cs ---
namespace SLYD.Domain.Entities.Cloudflare;

public class CreateTunnelResponse
{
    public bool success { get; set; }
    public List<string> errors { get; set; }
    public List<string> messages { get; set; }
    public Result result { get; set; }
    
    public class CredentialsFile
    {
        public string AccountTag { get; set; }
        public string TunnelID { get; set; }
        public string TunnelName { get; set; }
        public string TunnelSecret { get; set; }
    }
    
    public class Result
    {
        public string id { get; set; }
        public string account_tag { get; set; }
        public DateTime created_at { get; set; }
        public DateTime? deleted_at { get; set; }
        public string name { get; set; }
        public List<string> connections { get; set; }
        public DateTime? conns_active_at { get; set; }
        public DateTime? conns_inactive_at { get; set; }
        public string tun_type { get; set; }
        public Dictionary<string, object> metadata { get; set; }
        public string status { get; set; }
        public bool remote_config { get; set; }
        public CredentialsFile credentials_file { get; set; }
        public string token { get; set; }
    }
}EOF
--- FILE: Domain/Entities/Cloudflare/DnsRecord.cs ---
namespace SLYD.Domain.Entities.Cloudflare;

public class DnsRecord
{
    public string type { get; set; }
    public bool proxied { get; set; }
    public string name { get; set; }
    public string content { get; set; }
}

public class Meta
{
    public bool auto_added { get; set; }
    public bool managed_by_apps { get; set; }
    public bool managed_by_argo_tunnel { get; set; }
}

public class DnsRecordResult
{
    public string id { get; set; }
    public string zone_id { get; set; }
    public string zone_name { get; set; }
    public string name { get; set; }
    public string type { get; set; }
    public string content { get; set; }
    public bool proxiable { get; set; }
    public bool proxied { get; set; }
    public int ttl { get; set; }
    public object settings { get; set; }
    public Meta meta { get; set; }
    public object comment { get; set; }
    public List<object> tags { get; set; }
    public DateTime created_on { get; set; }
    public DateTime modified_on { get; set; }
}

public class DnsApiResponse
{
    public DnsRecordResult result { get; set; }
    public bool success { get; set; }
    public List<object> errors { get; set; }
    public List<object> messages { get; set; }
}EOF
--- FILE: Domain/Entities/Cloudflare/GetSecretApiResponse.cs ---
namespace SLYD.Domain.Entities.Cloudflare;

public class GetSecretApiResponse
{
    public bool success { get; set; }
    public List<object> errors { get; set; }
    public List<object> messages { get; set; }
    public string result { get; set; }
}EOF
--- FILE: Domain/Entities/Cloudflare/GetTunnelStatus.cs ---
namespace SLYD.Domain.Entities.Cloudflare;

public class GetTunnelStatus
{
        public bool success { get; set; }
        public List<string> errors { get; set; }
        public List<string> messages { get; set; }
        public Result result { get; set; }
}

public class Result
{
    public Guid Id { get; set; }
    public string accounttag { get; set; }
    public DateTime createdat { get; set; }
    public DateTime? deletedat { get; set; }
    public string name { get; set; }
    public List<Connection> connections { get; set; }
    public DateTime connsactiveat { get; set; }
    public DateTime? connsinactiveat { get; set; }
    public string tuntype { get; set; }
    public Dictionary<string, object> metadata { get; set; }
    public string status { get; set; }
    public bool remoteconfig { get; set; }
}

public class Connection
{
    public string coloname { get; set; }
    public string uuid { get; set; }
    public Guid Id { get; set; }
    public bool ispendingreconnect { get; set; }
    public string originip { get; set; }
    public DateTime openedat { get; set; }
    public string clientid { get; set; }
    public string clientversion { get; set; }
}EOF
--- FILE: Domain/Entities/Identity/TokenProvider.cs ---
namespace SLYD.Domain.Entities.Identity;

public class TokenProvider
{
    public string? IdToken { get; set; }
    public string? AccessToken { get; set; }
    public string? RefreshToken { get; set; }
}EOF
--- FILE: Domain/Entities/Lxd/GetOperation.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class GetOperation
{
    public class Progress
    {
        public string percent { get; set; }
        public string speed { get; set; }
        public string stage { get; set; }
    }

    public class MetadataDetails
    {
        public string create_instance_from_image_unpack_progress { get; set; }
        public Progress progress { get; set; }
    }

    public class Resources
    {
        public List<string> containers { get; set; }
        public List<string> instances { get; set; }
    }

    public class Metadata
    {
        public Guid Id { get; set; }
        public string @class { get; set; }
        public string description { get; set; }
        public DateTime created_at { get; set; }
        public DateTime updated_at { get; set; }
        public string status { get; set; }
        public int status_code { get; set; }
        public Resources resources { get; set; }
        public MetadataDetails metadata { get; set; }
        public bool may_cancel { get; set; }
        public string err { get; set; }
        public string location { get; set; }
    }

    public class ApiResponse
    {
        public string type { get; set; }
        public string status { get; set; }
        public int status_code { get; set; }
        public string operation { get; set; }
        public int error_code { get; set; }
        public string error { get; set; }
        public Metadata metadata { get; set; }
    }
}EOF
--- FILE: Domain/Entities/Lxd/GetOperationResponse.cs ---
namespace Domain.Entities.Lxd.Operations;

public class OperationResponse
{
    public Guid id { get; set; }
    public string @class { get; set; }
    public string description { get; set; }
    public DateTime created_at { get; set; }
    public DateTime updated_at { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public resources resources { get; set; }
    public metadatadetails metadata { get; set; }
    public bool may_cancel { get; set; }
    public string err { get; set; }
    public string location { get; set; }
}

public class progress
{
    public string percent { get; set; }
    public string speed { get; set; }
    public string stage { get; set; }
}

public class metadatadetails
{
    public string create_instance_from_image_unpack_progress { get; set; }
    public progress progress { get; set; }
}

public class resources
{
    public List<string> containers { get; set; }
    public List<string> instances { get; set; }
}EOF
--- FILE: Domain/Entities/Lxd/InstanceConsole.cs ---
namespace SLYD.Domain.Entities;

public class InstanceConsole
{
    public class Response{
        public string type { get; set; }
        public string status { get; set; }
        public int status_code { get; set; }
        public string operation { get; set; }
        public int error_code { get; set; }
        public string error { get; set; }
        public Metadata metadata { get; set; }

        public class Metadata
        {
            public Guid Id { get; set; }
            public string @class { get; set; }
            public string description { get; set; }
            public DateTime created_at { get; set; }
            public DateTime updated_at { get; set; }
            public string status { get; set; }
            public int status_code { get; set; }
            public Resources resources { get; set; }
            public MetadataInner metadata { get; set; }
            public bool may_cancel { get; set; }
            public string err { get; set; }
            public string location { get; set; }
        }

        public class Resources
        {
            public List<string> containers { get; set; }
            public List<string> instances { get; set; }
        }

        public class MetadataInner
        {
            public Dictionary<string, string> fds { get; set; }
        }
    }
}EOF
--- FILE: Domain/Entities/Lxd/Operation.cs ---
using System.Text.Json.Serialization;

namespace SLYD.Domain.Entities.Operation;

public class OperationResponse
{
    public string type { get; set; }

    public string status { get; set; }

    public int status_code { get; set; }

    public string operation { get; set; }

    public int error_code { get; set; }

    public string error { get; set; }

    public Metadata metadata { get; set; }
}

public class Metadata
{
    public Guid Id { get; set; }

    public string @class { get; set; }

    public string description { get; set; }

    public DateTime created_at { get; set; }

    public DateTime updated_at { get; set; }

    public string status { get; set; }

    public int status_code { get; set; }

    public Resources resources { get; set; }

    public object metadata_details { get; set; }

    public bool may_cancel { get; set; }

    public string err { get; set; }

    public string location { get; set; }
}

public class Resources
{
    [JsonPropertyName("containers")]
    public string[] Containers { get; set; }

    [JsonPropertyName("instances")]
    public string[] Instances { get; set; }
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: Domain/Entities/Lxd/ProviderServerResources.cs ---
namespace SLYD.Domain.Entities.Lxd;

public class ProviderServerResources
{

    public string type { get; set; }
    public string status { get; set; }
    public int status_code { get; set; }
    public string operation { get; set; }
    public int error_code { get; set; }
    public string error { get; set; }
    public Metadata metadata { get; set; }


public class Metadata
{
    public Cpu cpu { get; set; }
    public Memory memory { get; set; }
    public Gpu gpu { get; set; }
    public Network network { get; set; }
    public Storage storage { get; set; }
    public Pci pci { get; set; }
    public SystemInfo system { get; set; }
}

public class Cpu
{
    public string architecture { get; set; }
    public List<Socket> sockets { get; set; }
    public int total { get; set; }
}

public class Socket
{
    public string name { get; set; }
    public string vendor { get; set; }
    public int socket { get; set; }
    public List<Cache> cache { get; set; }
    public List<Core> cores { get; set; }
    public int frequency { get; set; }
    public int frequency_minimum { get; set; }
    public int frequency_turbo { get; set; }
}

public class Cache
{
    public int level { get; set; }
    public string type { get; set; }
    public int size { get; set; }
}

public class Core
{
    public int core { get; set; }
    public int die { get; set; }
    public List<Thread> threads { get; set; }
    public int frequency { get; set; }
}

public class Thread
{
    public int id { get; set; }
    public int numa_node { get; set; }
    public int thread { get; set; }
    public bool online { get; set; }
    public bool isolated { get; set; }
}

public class Memory
{
    public List<Node> nodes { get; set; }
    public int hugepages_total { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_size { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Node
{
    public int numa_node { get; set; }
    public int hugepages_used { get; set; }
    public int hugepages_total { get; set; }
    public long used { get; set; }
    public long total { get; set; }
}

public class Network
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}

public class Gpu
{
    public List<Card> cards { get; set; }
    public int total { get; set; }
}
public class Card
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public List<Port> ports { get; set; }
    public Sriov sriov { get; set; }
    public int numa_node { get; set; }
    public Nvidia? nvidia { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public string firmware_version { get; set; }
}

public class Nvidia
{
    public string cuda_version { get; set; }
    public string nvrm_version { get; set; }
    public string brand { get; set; }
    public string model { get; set; }
    public string uuid { get; set; }
    public string architecture { get; set; }
    public string card_name { get; set; }
    public string card_device { get; set; }
}

public class Port
{
    public Guid Id { get; set; }
    public string address { get; set; }
    public int port { get; set; }
    public string protocol { get; set; }
    public List<string> supported_modes { get; set; }
    public List<string> supported_ports { get; set; }
    public string port_type { get; set; }
    public string transceiver_type { get; set; }
    public bool auto_negotiation { get; set; }
    public bool link_detected { get; set; }
}

public class Sriov
{
    public int current_vfs { get; set; }
    public int maximum_vfs { get; set; }
    public object vfs { get; set; }
}

public class Storage
{
    public List<Disk> disks { get; set; }
    public int total { get; set; }
}

public class Disk
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public string model { get; set; }
    public string type { get; set; }
    public bool read_only { get; set; }
    public bool mounted { get; set; }
    public long size { get; set; }
    public bool removable { get; set; }
    public string wwn { get; set; }
    public int numa_node { get; set; }
    public string device_path { get; set; }
    public int block_size { get; set; }
    public string firmware_version { get; set; }
    public int rpm { get; set; }
    public string serial { get; set; }
    public string device_id { get; set; }
    public List<Partition> partitions { get; set; }
    public string pci_address { get; set; }
}

public class Partition
{
    public Guid Id { get; set; }
    public string device { get; set; }
    public bool read_only { get; set; }
    public long size { get; set; }
    public int partition { get; set; }
    public bool mounted { get; set; }
}

public class Pci
{
    public List<Device> devices { get; set; }
    public int total { get; set; }
}

public class Device
{
    public string driver { get; set; }
    public string driver_version { get; set; }
    public int numa_node { get; set; }
    public string pci_address { get; set; }
    public string vendor { get; set; }
    public string vendor_id { get; set; }
    public string product { get; set; }
    public string product_id { get; set; }
    public int iommu_group { get; set; }
    public Vpd vpd { get; set; }
}

public class Vpd
{
    // Add properties here if "vpd" object has any keys in the actual JSON
}

public class SystemInfo
{
    public string uuid { get; set; }
    public string vendor { get; set; }
    public string product { get; set; }
    public string family { get; set; }
    public string version { get; set; }
    public string sku { get; set; }
    public string serial { get; set; }
    public string type { get; set; }
    public Firmware firmware { get; set; }
    public Chassis chassis { get; set; }
    public Motherboard motherboard { get; set; }
}

public class Firmware
{
    public string vendor { get; set; }
    public string date { get; set; }
    public string version { get; set; }
}

public class Chassis
{
    public string vendor { get; set; }
    public string type { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}

public class Motherboard
{
    public string vendor { get; set; }
    public string product { get; set; }
    public string serial { get; set; }
    public string version { get; set; }
}
}EOF
--- FILE: LxdBackground/Properties/launchSettings.json ---
﻿{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:56656",
      "sslPort": 44350
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5092",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7006;http://localhost:5092",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}EOF
--- FILE: LxdBackground/Services/LxdFactoryService.cs ---
using System.Diagnostics;
using SLYD.Application.Interfaces.Repositories;
using SLYD.Domain.Models.ProviderModels;

namespace LxdBackground.Services;

public class LxdFactoryService
{    
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<LxdFactoryService> _logger;
    private List<ProviderServer> providerServers;
    private IProviderServerRepository _providerServerRepository;
    private HttpClient _httpClient;

    private const int MaxRetryAttempts = 5;
    private const int InitialDelayMilliseconds = 1000;

    public LxdFactoryService(ILogger<LxdFactoryService> logger, IConfiguration configuration, IProviderServerRepository providerServerRepository, HttpClient httpClient, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _providerServerRepository = providerServerRepository;
        _httpClient = httpClient;
        _serviceProvider = serviceProvider;
    }

    public async Task GetLxdStats()
    {
        const int delayMinutes = 5;
        const int delayMilliseconds = delayMinutes * 60 * 1000;

        while (true)
        {
            var stopwatch = Stopwatch.StartNew();

            providerServers = await _providerServerRepository.GetProvisionedServersAsync();

            foreach (var server in providerServers)
            {
                int retryAttempts = 0;
                int delay = InitialDelayMilliseconds;

                while (retryAttempts < MaxRetryAttempts)
                {
                    try
                    {
                        using (var scope = _serviceProvider.CreateScope())
                        {
                            var providerServerRepository =
                                scope.ServiceProvider.GetRequiredService<IProviderServerRepository>();

                            // Logic for LXD here
                            string lxdUri =
                                await providerServerRepository.GetProviderServerLxdUriFromServerId(server.Id);
                            var uri = "https://" + lxdUri + "/1.0/instances?project=default";

                            HttpResponseMessage response = await _httpClient.GetAsync(uri);

                            if (response.IsSuccessStatusCode)
                                await providerServerRepository.AddProviderServerMetrics(server.Id, true);
                            else
                                await providerServerRepository.AddProviderServerMetrics(server.Id, false);

                            _logger.LogInformation("Connected to LXD Server");
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        retryAttempts++;
                        _logger.LogError($"Connection attempt {retryAttempts} failed: {ex.Message}");

                        if (retryAttempts >= MaxRetryAttempts)
                        {
                            _logger.LogError("Max retry attempts reached. Moving to next server.");
                        }

                        await Task.Delay(delay);
                        delay *= 2; // Exponential backoff
                    }
                }
            }

            stopwatch.Stop();
            int elapsedMilliseconds = (int)stopwatch.ElapsedMilliseconds;

            if (elapsedMilliseconds < delayMilliseconds)
            {
                int remainingDelay = delayMilliseconds - elapsedMilliseconds;
                await Task.Delay(remainingDelay);
            }
        }
    }
}EOF
--- FILE: LxdBackground/appsettings.json ---
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
EOF
--- FILE: RabbitConsumer/Dockerfile ---
﻿FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 6000

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["RabbitConsumer/RabbitConsumer.csproj", "RabbitConsumer/"]
COPY ["Application/Application.csproj", "Application/"]
COPY ["Domain/Domain.csproj", "Domain/"]
COPY ["Infrastructure/Infrastructure.csproj", "Infrastructure/"]
RUN dotnet restore "RabbitConsumer/RabbitConsumer.csproj"
COPY . .
WORKDIR "/src/RabbitConsumer"
RUN dotnet build "RabbitConsumer.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "RabbitConsumer.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENV ASPNETCORE_ENVIRONMENT=Development
EEOF
N--- FILE: RabbitConsumer/Program.cs ---
using Serilog;
using Microsoft.EntityFrameworkCore;
using RabbitRecieverFactory.Services;
using SLYD.Infrastructure.Data;
using SLYD.Application;
using SLYD.Application.Services;
using SLYD.Infrastructure;

string environment = Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT") ?? "Development";
Console.WriteLine($"DOTNET_ENVIRONMENT: {Environment.GetEnvironmentVariable("DOTNET_ENVIRONMENT")}"); // Log the environment variable

Environment.SetEnvironmentVariable("DOTNET_ENVIRONMENT", environment);

HostApplicationBuilderSettings settings = new()
{
    Args = args,
    Configuration = new ConfigurationManager(),
    ContentRootPath = Directory.GetCurrentDirectory(),
};

settings.Configuration.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true);

settings.Configuration.AddEnvironmentVariables(prefix: "PREFIX_");
settings.Configuration.AddCommandLine(args);

var builder = Host.CreateApplicationBuilder(settings);

//Add support to logging with SERILOG
builder.Services.AddSerilog((services, loggerConfiguration) => loggerConfiguration
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day));

builder.Services.AddHostedService<WorkerService>();
builder.Services.AddSingleton<IConfiguration>(builder.Configuration);
builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);
builder.Services.AddSingleton<RabbitFactoryService>();
builder.Services.AddTransient<HttpClient>();
builder.Services.AddScoped<MessageDispatcher>();


builder.Services.AddDbContext<SlydDbContext>(
    options => options.UseNpgsql(builder.Configuration.GetConnectionString("Conn")),
    ServiceLifetime.Scoped);

var host = builder.Build();
hEOF
o--- FILE: RabbitConsumer/appsettings.json ---
{
  "Serilog": {
    "Using":  [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": "Information",
    "WriteTo": [
      { "Name": "Console" },
      { "Name": "File", "Args": { "path": "Logs/log.txt" } }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "AllowedHosts": "*"
}EOF
s--- FILE: WebUI/Dockerfile ---
﻿FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 5080

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["WebUI/WebUI.csproj", "WebUI/"]
COPY ["Application/Application.csproj", "Application/"]
COPY ["Domain/Domain.csproj", "Domain/"]
COPY ["Infrastructure/Infrastructure.csproj", "Infrastructure/"]
RUN dotnet restore "WebUI/WebUI.csproj"
COPY . .
WORKDIR "/src/WebUI"
RUN dotnet build "WebUI.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "WebUI.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
EEOF
N--- FILE: WebUI/Program.cs ---
using System.Security.Cryptography.X509Certificates;
using MudBlazor.Services;
using SLYD.Application;
using SLYD.Components;
using SLYD.Infrastructure;
using Serilog;
using SLYD.Application.Interfaces.Infrastructure.Internal;

var builder = WebApplication.CreateBuilder(args);

//Add support to logging with SERILOG
builder.Host.UseSerilog((context, configuration) =>
    configuration.ReadFrom.Configuration(context.Configuration));

// Add MudBlazor services
builder.Services.AddMudServices();

// Add Services
builder.Services.AddControllers();
builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);

var certPem = File.ReadAllText("pubkey.pem");
var keyPem = File.ReadAllText("privkey.pem");
var x509 = X509Certificate2.CreateFromPem(certPem, keyPem);

builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenAnyIP(5080, options => { options.UseHttps(x509); });
});

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

var app = builder.Build();

// Call the seeding method
using (var scope = app.Services.CreateScope())
{
    var scriptSeedService = scope.ServiceProvider.GetRequiredService<IScriptSeedService>();
    scriptSeedService.SeedInstallScript().Wait();
}

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    app.UseHsts();
}

//Add support to logging request with SERILOG
app.UseSerilogRequestLogging();
app.UseHttpsRedirection();
app.UseRouting();

//Work Around For ECS Health Check
var options = new DefaultFilesOptions();
options.DefaultFileNames.Clear();
options.DefaultFileNames.Add("healthcheck.html");

app.UseDefaultFiles(options);
app.UseStaticFiles();
app.UseAntiforgery();
app.UseAuthentication(); 
app.UseAuthorization();

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();  // This line maps the controllers
});

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

t", "WebUI.dll"]t.Run();TRYPOINT ["dotnet", "RabbitConsumer.dll"]
